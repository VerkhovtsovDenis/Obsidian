#### Нарушение локальности данных

#todo - вставить конспект с лекции 11.10, если найду на ноутбуке

**Когерентность кэша** cache coherency — состояние согласованности данных в кэше и памяти или также в кэшах разных ядер, если они ссылаются на один и тот же участок памяти. Когерентность нарушается операциями записи. Чем быстрее восстанавливается состояние когерентности, тем эффективнее осуществляется обмен данными через разделяемую память (между разными устройствами компьютерной системы, между ядрами процессора).

При работе с параллелизмом возникает такая вещь, как ложное разделение.
Ложное разделение данных false data sharing — **одновременное использование разными ядрами процессора или разными устройствами разных фрагментов одной строки памяти** (например, соседних элементов массива) [\[1\]](https://teccxx.neocities.org/mx1/memory2#:~:text=%D0%9B%D0%BE%D0%B6%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20false%20data,%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%2C%20%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%BD%D0%B8%D1%85%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2%20%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0).

 Cтрока компиляции для g++ компилятора листинга 2.1 на intel будет иметь вид:
 `g++ listing\ 2.1.cpp -o out.exe --std=c++11 --openmp`
##### Листинг 2
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <iomanip>
#include <omp.h>

unsigned sum_omp_reduce(const unsigned* V, unsigned n, unsigned b, unsigned e) {
    unsigned sum = 0;
    #pragma omp parallel for reduction (+ :sum)
    for (int i = b; i < e; ++i)
        sum += V[i];
    return sum;
}

int main(){
    using std::cin;
    using std::cout;
    using std::endl;
    // Количество элементов в массиве
    unsigned n = 1u << 24;

    // Общее количество потоков
    unsigned T = omp_get_num_threads();

    // Количество элементов, над которые будут заняты парралельным процессом
    unsigned s = n / T;

    // Индекс 0-го элемента подпоследовательности [b; b+s)
    unsigned b = n % T;
    
    #pragma omp parallel
    {
        // Номер текущего потока
        unsigned t = omp_get_thread_num();

        std::vector<unsigned> v(n);
        
        #pragma omp single
        {
            T = omp_get_num_threads();

            for(int i = 0; i < n; ++i)
                v[i] = i + T;
        }

        if (t < b)
            b = ++s * t;
        else
            b += s++;

        cout << "Thread " << t << "; b is " << b << endl;

        unsigned e = b + s;
        unsigned answer = sum_omp_reduce(v.data(), v.size(), b, e);

        cout << "answer is " << answer << endl;
    }

    std::cin.get();
    return 0;
}
```