### Логическое разделение данных и уровни кэш-памяти

Современные процессоры обычно имеют несколько уровней кэш-памяти:

- **L1** — самый быстрый, но маленький кэш, доступный для каждого ядра индивидуально.
- **L2** — больше по объему, но с меньшей скоростью доступа; обычно также принадлежит каждому ядру.
- **L3** — общий кэш для нескольких ядер, доступ к которому осуществляется медленнее, чем к L1 или L2.

Для эффективной работы многопоточных приложений важно учитывать структуру кэш-памяти, так как данные извлекаются в кэш порциями (типичная длина строки кэша составляет **64 байта** на платформе Intel x86/x64). Скорость доступа к данным варьируется в зависимости от уровня кэша:

- Доступ к L1 быстрее, чем к L2, примерно в **10 раз**.
- Доступ к L2 быстрее, чем к L3, примерно в **10 раз**.
- Доступ к оперативной памяти (RAM) значительно медленнее всех уровней кэша.

---

### Локальность данных

Локальность данных — ключевая концепция для оптимизации многопоточных программ:

- **Временная локальность**: если данные недавно использовались, высока вероятность их повторного использования в ближайшее время.
- **Пространственная локальность**: данные, находящиеся рядом в памяти, вероятно, будут использоваться вместе.

**Кэш-строка** — это минимальная единица данных, которая загружается из оперативной памяти в кэш. Для современных процессоров (например, Intel x86/x64) размер строки кэша составляет **64 байта**. Для повышения локальности и уменьшения количества пропусков (cache miss), разработчики стараются размещать часто используемые данные в одной кэш-строке.

---

### Ложное разделение данных

Ложное разделение возникает, когда разные потоки работают с разными данными, но эти данные попадают в одну и ту же строку кэша. Это приводит к ситуации, когда:

1. Поток изменяет данные в строке кэша.
2. Процессор должен синхронизировать строки кэша между ядрами (восстанавливать когерентность кэша).
3. Производительность значительно падает из-за частых пропусков кэша.

Пример: если массив типа `unsigned` (4 байта) хранится последовательно, то 16 элементов массива будут занимать одну строку кэша. Если каждый поток обрабатывает свой элемент массива, ложное разделение может негативно сказаться на производительности.

---

### Способы борьбы с ложным разделением

Чтобы избежать ложного разделения, можно использовать выравнивание данных:

1. **Использование выравнивания в структурах**:
##### Листинг 2.1 - Использование выравнивания в структурах
```cpp
struct Padding {
    unsigned value;
    char padding[64 - sizeof(unsigned)];
};
```    
    
2. **Использование стандартных возможностей C++**: Начиная с C++11, введены:
    
    - `std::hardware_destructive_interference_size` — размер, используемый для предотвращения разрушительного разделения данных (64 байта на x86).
    - `std::hardware_constructive_interference_size` — размер, который улучшает совместное использование данных.
3. **Разделение массива с учетом выравнивания**: Создание массива, где каждый элемент гарантированно занимает отдельную строку кэша:
##### Листинг 2.2
```cpp
 alignas(64) unsigned aligned_array[T];
```
    

---

### Пример применения для избежания ложного разделения
##### Листинг 2.3
```cpp
#include <iostream>
#include <vector>
#include <thread>
#include <atomic>

struct AlignedCounter {
    alignas(64) std::atomic<unsigned> counter;
};

void increment(AlignedCounter* counters, unsigned index, unsigned iterations) {
    for (unsigned i = 0; i < iterations; ++i) {
        counters[index].counter++;
    }
}

int main() {
    const unsigned num_threads = 4;
    const unsigned iterations = 1000000;

    AlignedCounter counters[num_threads];

    std::vector<std::thread> threads;
    for (unsigned i = 0; i < num_threads; ++i) {
        threads.emplace_back(increment, counters, i, iterations);
    }

    for (auto& t : threads) {
        t.join();
    }

    for (unsigned i = 0; i < num_threads; ++i) {
        std::cout << "Counter " << i << ": " << counters[i].counter << "\n";
    }

    return 0;
}

```

В этом примере каждый поток работает с отдельной кэш-строкой, что минимизирует ложное разделение.

---

**Когерентность кэша** cache coherency — состояние согласованности данных в кэше и памяти или также в кэшах разных ядер, если они ссылаются на один и тот же участок памяти. Когерентность нарушается операциями записи. Чем быстрее восстанавливается состояние когерентности, тем эффективнее осуществляется обмен данными через разделяемую память (между разными устройствами компьютерной системы, между ядрами процессора). 

При работе с параллелизмом возникает такая вещь, как ложное разделение. Ложное разделение данных false data sharing — **одновременное использование разными ядрами процессора или разными устройствами разных фрагментов одной строки памяти** (например, соседних элементов массива) [\[1\]](https://teccxx.neocities.org/mx1/memory2#:~:text=%D0%9B%D0%BE%D0%B6%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20false%20data,%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%2C%20%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%BD%D0%B8%D1%85%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2%20%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0). 
##### Листинг 2.4

```cpp
unsigned T = omp_get_num_threads();
```
Общее количество потоков 
##### Листинг 2.5
```cpp
unsigned s = n / T;
```
Количество элементов массива, которые должен обрабатывать каждый поток. Используется для разбиения массива на приблизительно равные части между потоками. ##### Листинг 2.3
##### Листинг 2.6
```cpp
unsigned b = n % T;
```

Остаток от деления общего количества элементов массива `n` на количество потоков `T`. Показывает, сколько потоков получат на один элемент больше базового размера блока `s`. Использование: Для первых `b` потоков размер блока увеличивается на 1 (`s + 1`), чтобы справедливо распределить остаток элементов. Для остальных потоков размер блока остается равным `s`.
##### Пример 
пусть n = 10,
T = 3. 
Тогда s = n / T = 3 
b = n % T = 1

| t   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 2   | 2   | 2   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| i   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
Задача `b` — правильно определить начальный индекс участка массива для каждого потока. 

##### Листинг 2.7
```cpp
if (t < b)
	b = ++s * t;
else
	b += s++;
```

##### Листинг 2.8
```cpp
unsigned t = omp_get_thread_num();
```
`omp_get_thread_num` - функция, которая возвращает номер потока в текущей группе вызывающего потока [\[4\]](https://www.openmp.org/spec-html/5.0/openmpsu113.html). 
##### Листинг 2.9
```cpp
T = omp_get_num_threads();
```
`omp_get_num_threads` - функция, которая возвращает общее количество потоков в текущей группе [\[5\]](https://www.openmp.org/spec-html/5.0/openmpsu111.html).

Cтрока компиляции для g++ компилятора листинга 2.1 на intel будет иметь вид: `g++ listing\ 2.cpp -o out.exe --std=c++11 --openmp` 

##### Листинг 2.10
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <iomanip>
#include <omp.h>

unsigned sum_omp_reduce(const unsigned* V, unsigned n, unsigned b, unsigned e) {
    unsigned sum = 0;
    #pragma omp parallel for reduction (+ :sum)
    for (int i = b; i < e; ++i)
        sum += V[i];
    return sum;
}

int main(){
    using std::cin;
    using std::cout;
    using std::endl;
    // Количество элементов в массиве
    unsigned n = 1u << 24;

    // Общее количество потоков
    unsigned T = omp_get_num_threads();
    
    unsigned s = n / T;
    unsigned b = n % T;
    
    #pragma omp parallel
    {
        unsigned t = omp_get_thread_num();
        std::vector<unsigned> v(n);
        
        #pragma omp single
        {
            T = omp_get_num_threads();
            for(int i = 0; i < n; ++i)
                v[i] = i + T;
        }

        if (t < b)
            b = ++s * t;
        else
            b += s++;

        cout << "Thread " << t << "; b is " << b << endl;

        unsigned e = b + s;
        unsigned answer = sum_omp_reduce(v.data(), v.size(), b, e);

        cout << "answer is " << answer << endl;
    }

    std::cin.get();
    return 0;
}
```

### Заключение

Оптимизация работы с кэш-памятью и устранение ложного разделения — это важные аспекты повышения производительности многопоточных приложений. Использование локальности данных и правильное выравнивание структур позволяет значительно сократить задержки, вызванные когерентностью кэша.