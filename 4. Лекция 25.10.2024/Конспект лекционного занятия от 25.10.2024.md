#### Синхронизация потоков

**Пул потоков (Thread Pool)** — это фиксированный набор потоков, одновременно выполняющих независимые друг от друга задачи, помещенные в некоторый
![[Pasted image 20241201160636.png]]
Основная задача синхронизации потоков – управление последовательностью выполнения потоков во времени. Взаимное исключение (mutual exclusion) для предотвращения конфликтов доступа.

Средства реализации:
- **Mutex** (мьютекс):
    - Используется для блокировки ресурсов.
    - Взаимное исключение достигается блокировкой сигнала.
- Сети Петри (IEEE стандарт):
    - Применяются для моделирования процессов.
    - Примеры:
        - POSIX (pthread библиотеки).
        - Спин-блокировки (spin-lock).

![[Pasted image 20241201162001.png]]

Мьютекс (mutex - mutuallyexclusive), который также называют защелкой - это механизм изоляции, используемый программами для синхронизации доступа нескольких потоков к совместно используемым ресурсам.

##### Мьютексы в языке C++
Стандарт C++17 языка программирования **[C++](https://ru.wikipedia.org/wiki/C%2B%2B "C++")** определяет 6 различных классов мьютексов:

- `mutex` — мьютекс без контроля повторного захвата тем же потоком[\[1\]](https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81#cite_note-_bf61bc6623f84f5b-21);
- `recursive_mutex` — повторные захваты тем же потоком допустимы, ведётся подсчёт таких захватов[\[2\]](https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81#cite_note-_d59001e3bd96db64-22);
- `timed_mutex` — нет контроля повторного захвата тем же потоком, имеет дополнительные методы захвата мьютекса с возвратом значения `false` в случае истечения тайм-аута или по достижении указанного времени[\[3\]](https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81#cite_note-_7fb58b9f6f121cec-23);
- `recursive_timed_mutex` — повторные захваты тем же потоком допустимы, ведётся подсчёт таких захватов, имеет дополнительные методы захвата мьютекса с возвратом кода ошибки по истечении тайм-аута или по достижении указанного времени[\[4\]](https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81#cite_note-_c15b033d5365e1ff-24);
- `shared_mutex` — разделяемый мьютекс[\[5\]](https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81#cite_note-_0224f52bcb5f40d0-4);
- `shared_timed_mutex` — разделяемый мьютекс, имеет дополнительные методы захвата мьютекса с возвратом кода ошибки по истечении тайм-аута или по достижении указанного времени[\[6\]](https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81#cite_note-_0224f52bcb5f40d0-4).

Библиотека [Boost](https://ru.wikipedia.org/wiki/Boost "Boost") дополнительно обеспечивает именованные и межпроцессные мьютексы, а также разделяемые мьютексы, которые позволяют захватывать мьютекс для совместного владения несколькими потоками только для чтения данных с запретом на эксклюзивную запись на время захвата блокировки, что по сути представляет собой механизм блокировок чтения и записи[[25]](https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81#cite_note-25).

![[Pasted image 20241201162111.png]]
##### Пример использования мьютексов:
##### Листинг 4.1
```cpp
#pragma omp critical
{
    // Критическая секция
    sum += 1;

    while (ресурс занят) {
        // Ожидание освобождения ресурса
        вытесняться();
    }

    if (i < 6000 && ресурс занят) {
        вытесняться();
    } else if (i == 6000) {
        // Захват мьютекса
        omp_mutex_lock(h);
    }
}

```
##### Листинг 4.2
```cpp
// Методы, которыми мы опирируем при работе с queue
queue(int) q;
push();
pop();
front();
...

t = 0;
mtx.lock();
q.push(1);
cv.notify();
mtx.unlock();
...

mxt.lock();
while(q.empty())
	cv.wait(mtx);
int v = q.front();
q.pop();
mtx.unlock();

cout << v;
```
##### Рекомендации по работе с мьютексами
1. Используйте мьютексы для защиты совместно используемых данных.
2. Убедитесь, что каждый вызов `lock()` сопровождается вызовом `unlock()`.
3. Проверяйте возможные ошибки, связанные с покинутыми мьютексами.
4. Рассматривайте альтернативы (например, спин-блокировки) для более эффективного выполнения в некоторых сценариях.

##### Листинг 4.3
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <iomanip>
#include <omp.h>

unsigned r_r(unsigned *V, unsigned n){
    unsigned sum = 0;
    int T;
    
    #pragma omp parallel
    {
	    unsigned mysum;
	    
        unsigned t = omp_get_thread_num();
	    unsigned T = omp_get_num_threads();
    
	    unsigned s = n / T;
	    unsigned b = n % T;
    
        if (t < b)
            b = ++s * t;
        else
            b += s*t;

	    for (int i = b; i < e; i++)
	        mysum += V[i];

		# pragma omp critical
		{
			sum += mysum;
		}
    }

    std::cin.get();
    return sum;
}
```

