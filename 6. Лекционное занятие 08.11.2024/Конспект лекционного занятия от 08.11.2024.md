[Статья "Потоки, блокировки и условные переменные в C++11 [Часть 2]"](https://habr.com/ru/articles/182626/)

##### Листинг 6.1
```cpp
struct queue{
	std::queue<int> q;
	std::mutex mtx;
	std::condition_variable cv;
}
```
Здесь определена структура, содержащая `std::queue` для хранения элементов, `std::mutex` для синхронизации доступа, и `std::condition_variable` для управления потоками. В коде представлен правильный подход для реализации потокобезопасной очереди.

##### Листинг 6.2
```cpp

void push(queue &q, int v){
	q.mtx.lock();
	q.q.push_back(b);
	q.mtx.unlick();
	q.cv.notift();
}

int pop(queue &q){
	std::unique_lock l(q.mtx);
	while(q.q.empty())
		cv.wait();
	
	int result = q.q.front();
	q.q.pop();
	
	return result;
}

int main(){
	queue q; // Пример использования потокобезопасной очереди     
	push(q, 42);
	std::cout << "Popped: " << pop(q) << std::endl;
	return 0; 
}
```



![[Pasted image 20241206020949.png]]
![[Pasted image 20241206021050.png]]

mfence
**Барьер памяти** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") memory barrier, membar, memory fence, fence instruction) — вид [барьерной](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F "Барьерная синхронизация") [инструкции](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BD%D0%B0%D0%B1%D0%BE%D1%80%D0%B0_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4 "Архитектура набора команд"), которая приказывает [компилятору](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80 "Компилятор") (при генерации инструкций) и [центральному процессору](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80 "Центральный процессор") (при исполнении инструкций) устанавливать строгую последовательность между обращениями к памяти до и после барьера. Это означает, что все обращения к памяти перед барьером будут гарантированно выполнены до первого обращения к памяти после барьера.

Барьеры памяти необходимы, так как большинство современных процессоров использует оптимизации производительности, которые могут привести к [переупорядочиванию инструкций](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%BD%D0%BE%D0%B5_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5 "Внеочередное исполнение"). Также переупорядочивание обращений к памяти может быть вызвано компилятором в процессе оптимизации использования регистров целевого процессора. Такие перестановки обычно не влияют на корректность программы с одним потоком исполнения, но могут вызвать непредсказуемое поведение в многопоточных программах. Правила изменения порядка исполнения инструкций зависят от архитектуры. Некоторые архитектуры предоставляют несколько типов барьеров с различными гарантиями. Например, [amd64](https://ru.wikipedia.org/wiki/Amd64 "Amd64") предоставляет следующие инструкции: `SFENCE` ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") store fence), `LFENCE`([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") load fence), `MFENCE`([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") memory fence)[[1]](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8#cite_note-1). [Intel Itanium](https://ru.wikipedia.org/wiki/Intel_Itanium "Intel Itanium") обеспечивает отдельные «запоминающие» ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") acquire) и «освобождающие» ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") release) барьеры памяти, которые учитывают видимость операций чтения после записи с точки зрения читателя и писателя соответственно.


### notify_one

Метод `notify_one()` класса `std::condition_variable` используется для пробуждения **одного потока**, который ожидает сигнала на этой условной переменной.

### Основная идея

Когда поток вызывает `cv.wait()` на объекте типа `std::condition_variable`, он "засыпает", пока не получит сигнал от другого потока. Метод `notify_one()` отправляет такой сигнал, пробуждая **ровно один** поток из тех, что находятся в состоянии ожидания.

---

### Пример использования
#### 1. Код с использованием `notify_one`
##### Листинг 6.3
```cpp
#include <iostream>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>

std::queue<int> q;                  // Общая очередь
std::mutex mtx;                     // Мьютекс для защиты очереди
std::condition_variable cv;         // Условная переменная

void producer() {
    for (int i = 0; i < 5; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Симулируем работу

        std::unique_lock<std::mutex> lock(mtx); // Блокируем очередь
        q.push(i);                              // Добавляем элемент в очередь
        std::cout << "Produced: " << i << std::endl;

        cv.notify_one(); // Уведомляем один поток-потребитель
    }
}

void consumer() {
    for (int i = 0; i < 5; ++i) {
        std::unique_lock<std::mutex> lock(mtx);

        // Ожидаем, пока очередь не станет непустой
        cv.wait(lock, [] { return !q.empty(); });

        int value = q.front();
        q.pop();
        std::cout << "Consumed: " << value << std::endl;
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();

    return 0;
}


```

---

### Как работает `notify_one`:

1. **Производитель**:
    - Добавляет элемент в очередь.
    - Вызывает `cv.notify_one()` для пробуждения одного потребителя.
2. **Потребитель**:
    - Ожидает сигнал с помощью `cv.wait()`, проверяя, что очередь непустая.
    - После получения сигнала продолжает выполнение.

---

### Отличие от `notify_all`:

- **`notify_one()`** пробуждает **только один поток** (если потоки ожидают).
- **`notify_all()`** пробуждает **все ожидающие потоки**.

Использование `notify_one` предпочтительнее, если пробуждать нужно только один поток, поскольку это снижает нагрузку на процессор и уменьшает количество контекстных переключений.

Метод `notify_all()` класса `std::condition_variable` используется для пробуждения **всех потоков**, которые находятся в состоянии ожидания на этой условной переменной. Это полезно в ситуациях, когда сигнал важен для всех ожидающих потоков, а не только для одного.

---

### notify_all

### Основная идея

Когда несколько потоков вызывают `cv.wait()` на объекте `std::condition_variable`, они "засыпают" и ждут сигнала. Вызов `notify_all()` отправляет сигнал всем этим потокам, позволяя им продолжить выполнение.

---

### Пример использования

#### 1. Код с использованием `notify_all`

##### Листинг 6.4
```cpp
#include <iostream>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>

std::queue<int> q;                  // Общая очередь
std::mutex mtx;                     // Мьютекс для защиты очереди
std::condition_variable cv;         // Условная переменная

void producer() {
    for (int i = 0; i < 5; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Симулируем работу

        std::unique_lock<std::mutex> lock(mtx); // Блокируем очередь
        q.push(i);                              // Добавляем элемент в очередь
        std::cout << "Produced: " << i << std::endl;

        cv.notify_all(); // Уведомляем всех потребителей
    }
}

void consumer(int id) {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);

        // Ожидаем, пока очередь не станет непустой
        cv.wait(lock, [] { return !q.empty(); });

        int value = q.front();
        q.pop();
        std::cout << "Consumer " << id << " consumed: " << value << std::endl;

        if (value == 4) // Завершаем, когда последний элемент обработан
            break;
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer, 1);
    std::thread t3(consumer, 2);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}

```

---

### Как работает `notify_all`:

1. **Производитель**:
    - Добавляет элемент в очередь.
    - Вызывает `cv.notify_all()`, чтобы разбудить **все потоки**, которые могут обрабатывать данные.
2. **Потребители**:
    - После пробуждения все потоки проверяют условие (например, `!q.empty()`).
    - Один поток получает доступ к данным (благодаря мьютексу), остальные продолжают ожидание.

---

### Когда использовать `notify_all`:

- Когда **все ожидающие потоки** должны быть пробуждены (например, если все должны проверить обновленные данные).
- Если сигнал касается состояния, которое важно для всех ожидающих потоков (например, завершение работы или изменение общего ресурса).

---

### Отличие от `notify_one`:

- **`notify_one()`** пробуждает только один поток, что экономит ресурсы в случае, если данные подходят только для одного потока.
- **`notify_all()`** пробуждает все потоки, что полезно, когда все они должны проверить, могут ли продолжить выполнение. Однако это может вызвать избыточную нагрузку из-за большого числа проверок.