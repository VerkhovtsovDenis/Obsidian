##### Ğ›Ğ¸ÑÑ‚Ğ¸Ğ½Ğ³ 7.1
```cpp
// num_threads.h
void set_num_threads(unsigned T);
unsigned get_num_threads();
```

##### Ğ›Ğ¸ÑÑ‚Ğ¸Ğ½Ğ³ 7.2
```cpp
// num_threads.cpp
static unsigned g_num_threads = std::thread::hardware_concurrency();

void set_num_threads(unsigned T){
	g_num_threads = T;
	omp_set_num_threads(T);
}

unsigned get_num_threads(){
return g_num_threads;
}
```
ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ ĞºÑ€Ğ°ÑĞ¸Ğ²Ñ‹Ğ¹ ĞºĞ¾Ğ´ ğŸ˜

##### Ğ›Ğ¸ÑÑ‚Ğ¸Ğ½Ğ³ 7.3
```cpp
// main.cpp

#if !defined (__cplusplus) || __cplusplus < 20200000
	// Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Ğ²ĞµÑ€ÑĞ¸Ğ¹ C++ (Ğ´Ğ¾ C++20):
Â  Â  typedef unsigned (*sum_ptr) (const unsigned* V, size_t n);
#else
	// Ğ”Ğ»Ñ C++20 Ğ¸ Ğ½Ğ¾Ğ²ĞµĞµ:
Â  Â  template <class F> // #include type_traits
Â  Â  concept sum_callable = std::is_invocable_r<unsigned, F, const unsigned*, size_t>;
#endif
```
Ğ­Ñ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡ĞµĞ½Ğ¸Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¼Ğ¸ Ğ²ĞµÑ€ÑĞ¸ÑĞ¼Ğ¸ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ° C++ Ğ¿Ñ€Ğ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğ¸ Ñ‚Ğ¸Ğ¿Ğ° Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ‚Ğ° Ğ´Ğ»Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ÑÑ‚ÑŒ ÑÑƒĞ¼Ğ¼Ñƒ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ°.

##### Ğ›Ğ¸ÑÑ‚Ğ¸Ğ½Ğ³ 7.4
```cpp
struct table_row {
	unsigned T;
Â  Â  bool match;
Â  Â  double time;
Â  Â  double speedup;
Â  Â  double efficiency;
};
```
Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ´Ğ»Ñ Ğ·Ğ°Ğ¼ĞµÑ€Ğ° ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°. 

##### Ğ›Ğ¸ÑÑ‚Ğ¸Ğ½Ğ³ 7.5
```cpp
#include <chrono>
std::vector<table_row> run_experiment(sum_ptr sum) {
Â  Â  using std::chrono::duration_cast;
Â  Â  using std::chrono::milliseconds;
Â  Â  
Â  Â  unsigned P = get_num_threads();
Â  Â  std::vector<table_row> table(P);
Â  Â  
Â  Â  size_t n = 1 << 27;
Â  Â  auto V = std::make_unique<unsigned[]>(n);

Â  Â  for (unsigned T = 1; T <= P; ++T) {
Â  Â  Â  Â  for (size_t i = 0; i < sizeof(V) / sizeof(unsigned int); ++i) V[i] = i + T;
Â  Â  Â  Â  auto t0 = std::chrono::steady_clock::now();
Â  Â  Â  Â  table[T-1].match = (sum(V.get(), n) == 0xFC000000 + T - 1);
Â  Â  Â  Â  auto t1 = std::chrono::steady_clock::now();

		table[T - 1].T = T;
Â  Â  Â  Â  table[T - 1].time = duration_cast<milliseconds>(t1 - t0).count();
Â  Â  Â  Â  table[T - 1].speedup = table[0].time / table[T - 1].time;
Â  Â  Â  Â  table[T - 1].efficiency = table[T - 1].speedup / T;
Â  Â  }
Â  Â  return table;
}
```
Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ¿Ğ¾ ÑĞºÑĞ¿ĞµÑ€Ğ¸Ğ¼ĞµĞ½Ñ‚Ñƒ. 
sum_ptr - ÑÑÑ‹Ğ»ĞºĞ° Ğ½Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ñ… ÑÑƒĞ¼Ğ¼, ĞºĞ¾Ñ‚Ğ¾Ñ€ÑƒÑ Ğ¼Ñ‹ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ (Ğ±ĞµÑ€ĞµĞ¼ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ñ… ÑÑƒĞ¼Ğ¼ Ğ½Ğ° C++).
