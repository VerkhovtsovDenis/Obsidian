Эксперименты с SQL-запросами окончены, но работа с базами данных продолжается: теперь, на новом уровне знаний, нет причин откладывать работу с базой данных в Django-проекте.

Вы продолжите изучать фреймворк Django, и вот, чем вы займётесь в ближайшее время:

- узнаете, как в Django организована работа с базами данных;
- научитесь описывать таблицы при помощи Python-классов;
- разберётесь с тем, как можно управлять содержимым базы данных при помощи Python-кода в Django;
- попрактикуетесь составлять сложные запросы к базе данных и выводить на страницы проекта информацию, полученную из неё;
- подключите и настроите административный интерфейс для Django-проекта.

![](https://pictures.s3.yandex.net/resources/2_1_1_1718605797.png)

## **И что, всё это важно и нужно?**

Наладить обмен информацией между базой данных и приложением — одна из востребованных задач, которую решают именно бэкенд-разработчики.

## А что там по практике?

Вы продолжите развивать проект «Анфиса для друзей».

Первая версия фронтенда для проекта «Анфиса для друзей» готова и выглядит вполне нарядно, но сейчас проект похож на обложку без содержимого: смотрится красиво, но практической пользы — никакой. В проекте должны быть описания сортов мороженого, разделение сортов по категориям, данные о зарегистрированных пользователях и много всего прочего.

Кроме того, эти данные должны взаимодействовать и пересекаться на страницах проекта:

- У каждого сорта мороженого должна быть своя страница: там будет название, описание и какая-то ещё информация о нём.
- На главной странице проекта должны отображаться те сорта мороженого, которые отметит администратор сайта.

Вся эта информация будет записана в **базе данных**; базу нужно будет создать, настроить и наполнить.

Вот список задач, которые надо выполнить:

1. Подключить к проекту базу данных SQLite, в которой будут храниться данные о сортах мороженого, категории и информация о пользователях системы.
2. Настроить админ-зону — часть проекта, через которую можно управлять содержимым сайта (например, добавлять новые сорта мороженого в базу). Админ-зона доступна только для администратора — пользователя с полными правами доступа.
3. Вывести из базы данных информацию о мороженом на соответствующие страницы.

Не будем задерживать вас — приступайте к учёбе!

В Django запросы к БД составляются не на SQL, а на Python. На этом этапе в работу включается **Django ORM** (англ. **O**bject-**R**elational **M**apping, «Объектно-реляционное отображение» или преобразование) — часть фреймворка, которая «переводит» запросы с Python на SQL и обратно.

Таблицы в базе данных, отношения между ними, запросы к базе — всё это описывается с помощью классов и методов Python, а ORM превращает python-код в SQL-запросы.

Повторим успех экспериментальной базы данных ACME и создадим базу с фильмами, но на этот раз — в Django-проекте, с помощью ORM. Ориентироваться в работе будем на ту структуру БД, которую мы уже построили:

![](https://pictures.s3.yandex.net/resources/S02_234_1679038239.png)

### Первый этап: подключение БД к Django-проекту

В мире есть десятки популярных СУБД; Django 3.2 «из коробки» поддерживает [пять из них](https://docs.djangoproject.com/en/3.2/ref/databases/):

- PostgreSQL
- MariaDB
- MySQL
- Oracle
- SQLite (подключена по умолчанию).

Есть расширения, которые позволяют Django работать и с другими базами данных.

В этом курсе мы будем работать с **SQLite**.

За подключение и настройку БД в проекте отвечает константа `DATABASES` в _settings.py_:

```python
# <название проекта>/settings.py

DATABASES = {
    'default': {
        # К проекту по умолчанию подключена СУБД SQLite:  
        'ENGINE': 'django.db.backends.sqlite3',
        # Файл с базой данных находится в одной папке с manage.py.
        'NAME': BASE_DIR / 'db.sqlite3',
    }
} 
```

Прелесть Django состоит в том, что если появится необходимость подключить к проекту другую БД — будет достаточно поменять настройки в _settings.py_, а больше ничего менять не придётся.

### Описание таблиц

В Django-проекте **acme_project** управлять фильмами будет приложение **cinema**. После выполнения команды `python manage.py startapp cinema` будет создана структура файлов и папок этого приложения:

```
cinema/
├── migrations/
│   └── __init__.py
├── __init__.py
├── admin.py
├── apps.py
├── models.py        <-- Тут будем описывать классы для БД.
├── tests.py
└── views.py 
```

Каждое новое приложение обычно регистрируется в проекте через добавление новой записи в список `INSTALLED_APPS` в файле _settings.py_.

## Первая модель для первой таблицы

Таблицы БД создаются с помощью ORM в два этапа:

4. **Описание структуры** **БД**: в специальных Python-классах (их принято называть **моделями**) описывают типы полей и связи между таблицами.
5. **Создание и выполнение миграций**: при выполнении миграций Django ORM на основе **моделей** создаёт таблицы в БД.

Начнём работу с создания таблицы с фильмами: в приложении **cinema** создадим модель `VideoProduct` с одним полем: `title` (название фильма или другого видеопродукта).

Модели наследуются от класса `Model` из модуля `models`.

```python
# cinema/models.py
# Импортируем модуль с классом Model, от которого будем наследовать модели:
from django.db import models

class VideoProduct(models.Model):
    title = models.CharField(max_length=128) 
```

При выполнении миграций на основе этой модели Django ORM создаст и отправит такой SQL-запрос:

```sql
CREATE TABLE "cinema_videoproduct" (
  "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
  "title" varchar(128) NOT NULL
); 
```

В результате этого запроса в базе данных будет создана таблица **cinema_videoproduct**.

- Из названия приложения `Cinema` и названия модели `VideoProduct` Django ORM сгенерировал название для таблицы: **cinema_videoproduct**.
- В модели описано лишь одно поле, но в запросе видно, что будет создано два поля. Django ORM автоматически создаёт поле `id` — **первичный ключ** типа `INTEGER`. Параметр `AUTOINCREMENT` указывает, что для каждой новой записи значение этого числового поля будет автоматически увеличиваться на единицу.
- Поле `title` будет создано на основе атрибута `title` модели `VideoProduct`.  
    Тип этого поля определён классом `CharField(max_length=128)`; в синтаксисе SQL тип этого поля превратится в `VARCHAR`, длина строки будет ограничена: не более 128 символов. Значение `NOT NULL` добавлено автоматически, по умолчанию.

### Типы полей в Django

При описании поля модели его тип указывается при помощи специальных классов. Вот несколько популярных типов (в скобках — название аналогичного типа в SQL):

`models.IntegerField()` — натуральное число (INTEGER);

`models.FloatField()` — число с плавающей точкой (REAL);

`models.BooleanField()` — булев тип `False`/`True` (BOOL);

`models.CharField()` — строка (текстовое поле с ограничением по числу символов) (VARCHAR);

`models.TextField()` — текстовое поле (TEXT);

`models.DateField()` — дата, как `datetime.date` в Python (DATE);

`models.DateTimeField()` — дата и время, как `datetime.datetime` в Python (DATATIME);

`models.SlugField()` — «слаг», для строк, состоящих только из цифр, букв латиницы и символов `-` и `_`. Обычно слаг используют для создания человекочитаемых URL;

`models.ImageField()` — для изображений.

## На заметку

- Как подключить базу данных к проекту: описание в [официальной документации](https://docs.djangoproject.com/en/3.2/ref/databases/).
- В Django есть [множество типов полей БД](https://docs.djangoproject.com/en/3.2/ref/models/fields/#field-types) на все случаи жизни.


### Задание
В тренажёр загружен Django-проект «Анфиса для друзей». Ваша задача — подружить проект с базой данных.

В файле _models.py_ приложения _ice_cream_ создайте три модели:

- **Wrapper** (обёртки и упаковки мороженого)  
    `title` — строка (не более 256 символов);  
    `is_published` — булев тип (по умолчанию — `True`).
- **Topping** (топпинги — добавки для мороженого)  
    `title` — строка (не более 256 символов);  
    `slug` — поле типа _slug_ (не более 64 символов, уникальное в пределах таблицы).  
    `is_published` — булев тип (по умолчанию — `True`);
- **IceCream** (сорта мороженого)  
    `title` — строка (не более 256 символов);  
    `description` — текстовое поле.  
    `is_on_main` — булев тип (по умолчанию — `False`);  
    `is_published` — булев тип (по умолчанию — `True`);

Поле `is_published` будет определять, должна ли запись публиковаться на сайте или надо скрыть её от посетителей. Поле `is_on_main` указывает, должна ли запись выводиться на главную страницу проекта.

Как указываются типы полей, как задаются значения по умолчанию, как ограничивается число символов — найдите в документации Django или в тематических статьях.

Работа с документацией — это важная часть работы; все разработчики делают это!

```python
# models.py
from django.db import models

# Топпинги
class Toping(models.Model):
    title = models.CharField(max_length=256)
    slub = models.CharField(max_length=256)
    is_publishid = models.BooleanField(null=True)

# Обёртки
class Wrapper(models.Model):
    title = models.CharField(max_length=256)
    is_publishid = models.BooleanField(null=True)

# Сорта мороженого
class IceCream(models.Model):
    title = models.CharField(max_length=256)
    description = models.TextField()
    is_on_main = models.BooleanField(null=False)
    is_publishid = models.BooleanField(null=True)
```

