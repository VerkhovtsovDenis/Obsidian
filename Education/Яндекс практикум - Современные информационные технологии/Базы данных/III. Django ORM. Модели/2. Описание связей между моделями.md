В Django ORM таблицы описывают в моделях; связи между таблицами описывают тоже в моделях.

Таблицы в БД могут быть связаны отношениями

- «один к одному» (1:1): каждая запись одной таблицы может быть связана только с одной из записей другой таблицы;
- «многие к одному» (N:1): несколько записей одной таблицы могут быть связаны с одной и той же записью другой таблицы;
- «многие ко многим» (N:M): с каждой записью первой таблицы может быть связано несколько записей второй таблицы, а каждая запись второй таблицы может быть связана с несколькими записями первой.

### Модели, связанные «один к одному»

Продолжаем развивать проект ACME: создадим модель для оригинальных названий фильмов; назовём её `OriginalTitle` и свяжем с моделью `VideoProduct` «один к одному».

При описании связанных моделей важен порядок, в котором они размещены в коде: синтаксис описания связи отличается в зависимости от того, какая модель описана первой, а какая — второй.

Модель `VideoProduct` ссылается на модель `OriginalTitle`. Чтобы модели `VideoProduct` было на что сослаться — сперва опишем модель `OriginalTitle`, а ниже — `VideoProduct`:

```python
# cinema/models.py
from django.db import models

class OriginalTitle(models.Model):
    title = models.CharField(max_length=128)

class VideoProduct(models.Model):
    title = models.CharField(max_length=128)
    # Описываем поле, ссылающееся на модель OriginalTitle:
    original_title = models.OneToOneField(
        # На какую модель ссылаемся
        OriginalTitle,
        # Поведение при удалении:
        # если оригинальное имя будет удалено,
        # то и сам фильм будет удалён. 
        on_delete=models.CASCADE
    ) 
```

Ссылающуюся модель можно описать выше той, на которую она ссылается.

При миграции Django ORM создаст такие запросы:

```sql
CREATE TABLE "cinema_originaltitle" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
"title" varchar(128) NOT NULL
);

CREATE TABLE "cinema_videoproduct" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
"title" varchar(128) NOT NULL, 
"original_title_id" bigint NOT NULL UNIQUE REFERENCES "cinema_originaltitle" ("id")
); 
```

**Чудеса с именами**: имя поля `original_title` Django ORM превратил в `original_title_id`, приклеив к нему суффикс `_id`.

Переведём SQL-запрос на русский язык:

1. **Создай таблицу** `cinema_originaltitle` с такими полями:
    - `id` — автоинкрементный первичный ключ типа `integer`. При добавлении каждой новой записи значение в этом поле будет автоматически увеличиваться на единицу. Django ORM автоматически создаёт такое поле для каждой модели.
    - `title` — обязательное поле (`NOT NULL`) типа «строка»; длина строки — не более 128 символов.
2. **Создай таблицу** `cinema_videoproduct` с такими полями:
    - `id` — автоинкрементный первичный ключ типа `integer`.
    - `title` — обязательное поле (`NOT NULL`), строка не больше 128 символов;
    - `original_title_id` — **внешний ключ** типа `bigint` (большое целое число).  
        Тип `bigint` похож на тип `integer`; разница в том, что `integer` не может принимать значения более 2147483647, а у `bigint` этого ограничения нет. При большом количестве записей значение `id` может и преодолеть лимит, установленный для `integer`.  
        Поле `original_title_id` обязательное (не может быть `NULL`), с уникальным (`UNIQUE`) в пределах таблицы значением; в параметре `REFERENCES "cinema_originaltitle" ("id")` описано, что это поле ссылается на колонку `id` таблицы `cinema_originaltitle`.

После наполнения данными таблицы, созданные Django ORM, будут выглядеть примерно так:

![](https://pictures.s3.yandex.net/resources/image_1707808940.png)

### Обязательный аргумент для ссылающихся полей: on_delete

Возьмём вполне реальную ситуацию. Запись из таблицы `cinema_videoproduct` ссылается на запись таблицы `cinema_originaltitle`, но в какой-то момент запись из `cinema_originaltitle` удалили. В результате ссылка из `cinema_videoproduct` ведёт на несуществующий id; ссылочная целостность базы нарушена, всё сломалось.

При работе с Django ORM в описании связи не забывайте указывать аргумент `on_delete`, определяющий правила поведения при удалении связанных записей.

Инструкция `on_delete=models.CASCADE` в модели `VideoProduct` устанавливает такие правила: если удаляется запись из `cinema_originaltitle` — будет удалена и ссылающаяся на неё запись из таблицы `cinema_videoproduct`.

Есть и другой вариант: при удалении оригинального названия из таблицы `cinema_originaltitle` запись в таблице `cinema_videoproduct` можно сохранить; но для этого нужно сделать так, чтобы запись из `cinema_videoproduct` никуда не ссылалась (оригинального названия-то нет); в поле `original_title_id` этой записи нужно установить `NULL`.

Для этого в описании поля модели нужно задать параметр `on_delete=models.SET_NULL`. При удалении объекта, на который ведёт ссылка, в ссылающихся записях вместо ссылки на объект будет установлен `NULL`. Чтобы провернуть этот фокус с `SET_NULL` — поле `original_title_id` должно принимать значение `NULL`; для этого в описании поля модели указывают аргумент `null=True`:

```python
class VideoProduct(models.Model):
    ...
    original_title = models.OneToOneField(
        OriginalTitle,  
        on_delete=models.SET_NULL,
        null=True
    ) 
```

Для `on_delete` есть и [другие аргументы](https://docs.djangoproject.com/en/3.2/ref/models/fields/#arguments): `SET_DEFAULT`, `PROTECT` , `RESTRICT` и `DO_NOTHING`.

### Модели, связанные «многие к одному»

Продолжаем строить базу данных: создадим модель `ProductType`, которая будет описывать тип фильма. Связь между моделями `VideoProduct` и `ProductType` должна быть «многие к одному»: много фильмов могут относиться к одному типу.

![](https://pictures.s3.yandex.net/resources/image_1707808954.png)

Порядок описания моделей в коде имеет значение при любом типе связи.

> Если ссылающаяся модель описана в коде раньше той, на которую она ссылается — то имя модели, на которую ведёт ссылка, должно быть указано в кавычках.

Если же ссылающаяся модель описана после той, на которую она ссылается — кавычки не нужны.

Сперва опишем модель `ProductType`, а следом — `VideoProduct`, которая ссылается на `ProductType`.

Связь «многие к одному» указывается с помощью класса `ForeignKey`:

```python
# cinema/models.py
from django.db import models

class ProductType(models.Model):
    title = models.CharField(max_length=128)

class VideoProduct(models.Model):
    title = models.CharField(max_length=128)
    product_type = models.ForeignKey(
        ProductType,
        on_delete=models.CASCADE
    ) 
```

В описании связи обязательно должен быть указан аргумент `on_delete`, установим его как `models.CASCADE`.

При миграции будет отправлен такой SQL-запрос:

```sql
CREATE TABLE "cinema_producttype" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
 "title" varchar(128) NOT NULL
);

CREATE TABLE "cinema_videoproduct" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
"title" varchar(128) NOT NULL,
"product_type_id" bigint NOT NULL REFERENCES "cinema_producttype" ("id")
);
CREATE INDEX "cinema_videoproduct_producttype_id_12303e1b" ON "cinema_videoproduct" ("producttype_id"); 
```

Перевод:

1. **Создай таблицу** `cinema_producttype` с полями: `id` — автоинкрементный первичный ключ типа `integer`. `title` — обязательное поле, строка, не более 128 символов.
2. **Создай таблицу** `cinema_videoproduct` с полями: `id` — автоинкрементный первичный ключ типа `integer`. `title` — обязательное поле, строка, не более 128 символов. `product_type_id` — обязательное поле, **внешний ключ** типа `bigint`, ссылающийся на колонку `id` таблицы `cinema_producttype`. Инструкция `CREATE INDEX` создаёт вспомогательные структуры для быстрого получения информации из таблиц.

**Индекс** ускоряет обработку запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, как оглавление в книге помогает быстро найти необходимую информацию.

Django ORM автоматически создаёт индексы для таблиц, связанных через «многие к одному».

### Cвязь N:M «на коленке»

Оригинальные значения и типы фильмов подключили, осталось разобраться с режиссёрами. Создадим таблицу и для них.

У фильма может быть один режиссёр, а может быть целая команда, и всех их нужно связать с фильмом. Однако каждый режиссёр может быть автором нескольких фильмов.

Получается, записи таблиц фильмов и режиссёров должны быть связаны как «многие ко многим».

Такую связь можно создать через вспомогательную промежуточную таблицу:

![](https://pictures.s3.yandex.net/resources/S02_236_1679038813.png)

Как писать модели — известно, как сослаться из одной таблицы на другую — понятно. Почему бы не описать эту конструкцию в коде.

Создадим модель `Director` (в ней будем хранить информацию о режиссёрах) и модель для промежуточной таблицы —`DirectorVideoProduct`: в каждой записи этой таблицы будут сопоставлены `id` фильма и `id` связанного с ним режиссёра.

```python
from django.db import models

class VideoProduct(models.Model):
    title = models.CharField(max_length=128)

class Director(models.Model):
    full_name = models.CharField(max_length=128)

class DirectorVideoProduct(models.Model):
    video_product = models.ForeignKey(VideoProduct, on_delete=models.CASCADE)
    director = models.ForeignKey(Director, on_delete=models.CASCADE) 
```

Код получился чуть длиннее, чем в предыдущих примерах, но ничего нового в нём нет: названия и типы полей, описание связей — всё то же.

При выполнении миграции Django ORM прочтёт эти модели и отправит примерно такой запрос:

```sql
CREATE TABLE "cinema_director" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
"full_name" varchar(128) NOT NULL
);

CREATE TABLE "cinema_videoproduct" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
 "title" varchar(128) NOT NULL
);

CREATE TABLE "cinema_directorvideoproduct" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
"video_product_id" bigint NOT NULL REFERENCES "cinema_videoproduct" ("id"),
"director_id" bigint NOT NULL REFERENCES "cinema_director" ("id")
);
CREATE INDEX "cinema_directorvideoproduct_director_id_15834c71" 
    ON "cinema_directorvideoproduct" ("director_id");
CREATE INDEX "cinema_directorvideoproduct_videoproduct_id_7e980308"
    ON "cinema_directorvideoproduct" ("video_product_id"); 
```

Перевод SQL-запроса на русский:

- **Создай таблицу** `cinema_director` с полями `id` и `full_name` и таблицу `cinema_videoproduct` с полями `id` и `title`.
- **Создай таблицу** `cinema_directorvideoproduct` с такими полями:  
    `id` — автоинкрементный первичный ключ типа `integer`;  
    `video_product_id` — обязательное поле, **внешний ключ**, ссылающийся на колонку `id` в таблице `cinema_videoproduct`;  
    `director_id` — обязательное поле, **внешний ключ**, ссылающийся на колонку `id` в таблице `cinema_director`;
- Создай индексы: `CREATE INDEX`. Так доступ к данным в связанных таблицах будет быстрее.

### Связь N:M в Django ORM

В Django ORM для создания связи «многие ко многим» предусмотрен тип поля `ManyToManyField`:

```python
from django.db import models

class Director(models.Model):
    full_name = models.CharField(max_length=128)

class VideoProduct(models.Model):
    title = models.CharField(max_length=128)
    directors = models.ManyToManyField(Director)  # Вот оно, поле!  
```

Увидев инструкцию `models.ManyToManyField`, Django ORM поймёт, что без промежуточной таблицы не обойтись — и сам создаст её, не заставляя разработчика загромождать код вспомогательными моделями.

При миграции будет сгенерирован запрос, включающий и создание промежуточной таблицы:

```sql
CREATE TABLE "cinema_director" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
 "full_name" varchar(128) NOT NULL
);

CREATE TABLE "cinema_videoproduct" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
 "title" varchar(128) NOT NULL
);

CREATE TABLE "cinema_videoproduct_director" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
"videoproduct_id" bigint NOT NULL REFERENCES "cinema_videoproduct" ("id"),
"director_id" bigint NOT NULL REFERENCES "cinema_director" ("id")
);
CREATE UNIQUE INDEX 
"cinema_videoproduct_director_videoproduct_id_director_id_009e8ea6_uniq" 
    ON "cinema_videoproduct_director" ("videoproduct_id", "director_id");
CREATE INDEX "cinema_videoproduct_director_videoproduct_id_805e209b" 
    ON "cinema_videoproduct_director" ("videoproduct_id");
CREATE INDEX "cinema_videoproduct_director_director_id_2356c5d4" 
    ON "cinema_videoproduct_director" ("director_id"); 
```

SQL-запрос будет выглядеть почти так же, как и в предыдущем примере, где промежуточная таблица была описана вручную. Единственная разница — Django ORM создаст индекс по составному первичному ключу `'videoproduct_id', 'director_id'`.

В большинстве случаев стандартное поле `ManyToManyField` — это всё, что нужно для связи «многие ко многим». Но иногда в промежуточной модели требуется создать дополнительное поле, например, чтобы охарактеризовать связь между двумя моделями. В нашем примере в таком поле можно хранить информацию о дате начала работы конкретного режиссёра над конкретной картиной или причину, по которой для работы над фильмом выбрали именно этого режиссёра.

При использовании поля `ManyToManyField` Django ORM позволяет указать промежуточную модель, которая будет использоваться для управления отношениями «многие ко многим». В этой модели можно описать и дополнительные поля (например, добавить поле для текста, описывающего эту связь).

Промежуточная модель указывается при описании поля `ManyToManyField` при помощи параметра `through`. Для нашего кинематографического примера код будет выглядеть так:

```python
from django.db import models

class Director(models.Model):
    full_name = models.CharField(max_length=128)

class VideoProduct(models.Model):
    title = models.CharField(max_length=128)
    # Параметр through указывает, какую модель надо назначить промежуточной:
    directors = models.ManyToManyField(Director, through='Partnership')

class Partnership(models.Model):
    # Поле, ссылающееся на модель Director:
    director = models.ForeignKey(Director, on_delete=models.CASCADE)
    # Поле, ссылающееся на модель VideoProduct:
    videoproduct = models.ForeignKey(VideoProduct, on_delete=models.CASCADE)
    # Дополнительные поля:
    # дата начала работы режиссёра над фильмом...
    date_joined = models.DateField()
    # ...и история о том, почему на фильм пригласили именно этого режиссёра.
    invite_reason = models.CharField(max_length=300) 
```

В описании модели-посредника необходимо явно указать внешние ключи для моделей, связанных «многие ко многим» (в нашем примере это поля `director` и `videoproduct`). Это явное объявление и определяет, как связаны две модели.

При создании связи N:M разработчики в большинстве случаев применяют поле `ManyToManyField` (с параметром `through` или без него); при использовании этого поля Django ORM заметно упрощает работу со связанными моделями, предоставляя разработчику множество дополнительных инструментов, которых не получить, создав связь «на коленке».

## На заметку

- О том, как работают значения `SET_DEFAULT`, `PROTECT` , `RESTRICT` и `DO_NOTHING` для `on_delete`, можно узнать [в документации](https://docs.djangoproject.com/en/3.2/ref/models/fields/#django.db.models.CASCADE).

### Имя для обратной связи между таблицами

Если в модели описаны поля, для которых указан тип `ForeignKey`, то объекты связанной модели получают специальный интерфейс, через который можно получить доступ к объектам исходной модели. Для этого используется опциональный параметр `related_name`.

Этот параметр позволяет задать имя атрибута, используемого для обратной связи от связанной модели к модели, которая определяет отношение.

Вот пример использования `related_name`:

```python
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books') 
```

В этом примере, у модели `Book` есть поле `author`, связанное с моделью `Author` через ForeignKey. Параметр `related_name='books'` указывает, что для доступа ко всем книгам автора, связанным с объектом модели `Author`, можно использовать атрибут `books`. Например вот так:

```python
author = Author.objects.get(name='Александр Пушкин')
pushkin_books = author.books.all() 
```

Если не указывать `related_name`, то для доступа к связанным книгам пришлось бы использовать имя `book_set`. Такое имя генерируется автоматически добавлением префикса «_set» к имени модели.

```python
pushkin_books = author.book_set.all() 
```

Использование `related_name` удобно в случаях, когда:

- необходимо предоставить более понятное и читаемое имя для доступа к связанным объектам вместо использования автоматически сгенерированных имен.
- в случае, когда у модели есть несколько полей, связанных с другой моделью и `related_name` помогает различать имена обратных связей и предотвращает возможные конфликты имен.


### Задание
В файле _models.py_ приложения **ice_cream** описаны четыре модели:

- `Category` — категории сортов мороженого; каждое мороженое принадлежит лишь одной категории; одной категории может принадлежать несколько сортов;
- `Topping` — добавки к мороженому; к каждому мороженому может прилагаться несколько топпингов;
- `Wrapper` — обёртки для мороженого; у каждого сорта мороженого может быть только одна обёртка;
- `IceCream` — сорта мороженого.

В модель `IceCream` добавьте поля, связывающие её с остальными моделями:

- **С моделью** `Category`:
    - имя поля: `category`;
    - тип связи: N:1;
    - обязательное поле;
    - при удалении категории должны быть удалены все сорта мороженого из этой категории
- **С моделью** `Topping`:
    - имя поля: `toppings`;
    - тип связи: N:M;
    - обязательное поле;
- **С моделью** `Wrapper`:
    - имя поля: `wrapper`;
    - тип связи: 1:1;
    - необязательное поле;
    - при удалении связанной записи в этом поле должно быть установлено `NULL`.

```python
# models.py

from django.db import models

# Категории.
class Category(models.Model):
    is_published = models.BooleanField(default=True)
    title = models.CharField(max_length=256)
    slug = models.SlugField(max_length=64, unique=True)
    output_order = models.PositiveSmallIntegerField(default=100)

# Топпинги.
class Topping(models.Model):
    is_published = models.BooleanField(default=True)
    title = models.CharField(max_length=256)
    slug = models.SlugField(max_length=64, unique=True)
  
# Обёртки.
class Wrapper(models.Model):
    is_published = models.BooleanField(default=True)
    title = models.CharField(max_length=256)
  
# Сорта мороженого.
class IceCream(models.Model):
    is_published = models.BooleanField(default=True)
    is_on_main = models.BooleanField(default=False)
    title = models.CharField(max_length=256)
    description = models.TextField()
    
    # Создайте нужные связи между моделями:
    wrapper = models.OneToOneField(
        Wrapper,
        on_delete=models.SET_NULL,
        blank=True,
        null=True)
    
    category = models.ForeignKey(
        Category,
        on_delete=models.CASCADE
    )
    
    toppings = models.ManyToManyField(
        Topping,
        blank=True
    )
```