Неплохой результат! Несколько строк на Python — и появилась работоспособная база! И не понадобилось писать ни одного SQL-запроса: Django ORM всё сделал сам.

![](https://pictures.s3.yandex.net/resources/S02_234_1679039077.png)

Решим новую задачу: добавим временны́е метки ко всем записям; для каждой записи каждой таблицы будем сохранять время создания записи и время последнего изменения.

Для этого добавим во все таблицы поля `created_at` (время создания) и `modified_at` (время последнего изменения):

```python
...

class VideoProduct(BaseModel):
    ...
    created_at = models.DateTimeField(auto_now_add=True)
    modified_at = models.DateTimeField(auto_now_add=False, auto_now=True) 
```

Во всех моделях надо описать совершенно одинаковые поля; но дублирование кода — это дурной тон и нарушение принципа DRY. Повторов можно избежать: для этого в Django ORM применяют наследование от **абстрактных моделей**.

Практический смысл абстрактной модели в том, что в ней можно задать определённый набор свойств, затем унаследовать от неё другие модели — и все эти модели получат свойства, заданные в абстрактной модели-родителе.

Абстрактные модели — особенные: для них Django ORM не создаёт таблицы в БД.

Чтобы не запутаться в назначении классов, в названиях абстрактных моделей обычно используют слово **Model**: _BaseModel_, _CartModel_, _ProductModel_.

Опишем первую абстрактную модель — `BaseModel`; в ней определим класс `Meta` — **внутренний класс**, в котором описывают дополнительные настройки модели.

Класс `Meta` необязательный, он требуется не во всех классах, но в абстрактных моделях он необходим — именно в `Meta` модель объявляется абстрактной:

```python
class BaseModel(models.Model):
    """
    Абстрактная модель. 
    Добавляет к модели дату создания и последнего изменения. 
    """
    # Параметр auto_now_add=True означает
    # "при СОЗДАНИИ записи автоматически записывать в это поле текущее время".
    created_at = models.DateTimeField(auto_now_add=True)
    # Параметр auto_now=True означает
    # "при ИЗМЕНЕНИИ записи автоматически записывать в это поле текущее время".
    modified_at = models.DateTimeField(auto_now_add=False, auto_now=True)

    # С помощью необязательного внутреннего класса Meta можно добавить
    # к модели дополнительные настройки. 
    class Meta:
        # Эта строка объявляет модель абстрактной:
        abstract = True 
```

Унаследуем `VideoProduct` от `BaseModel` — и в модели `VideoProduct` не придётся явно описывать поля `created_at` и `modified_at`:

```python
...

class VideoProduct(BaseModel):
    title = models.CharField(max_length=128) 
```

SQL-запрос, который будет сгенерирован при миграции:

```sql
CREATE TABLE "cinema_videoproduct" 
("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
 "created_at" datetime NOT NULL,
 "modified_at" datetime NOT NULL,
 "title" varchar(128) NOT NULL
); 
```

Python поддерживает множественное наследование: можно создать несколько абстрактных моделей и наследоваться от них, просто перечислив их имена через запятую.

```python
...

class BaseModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    modified_at = models.DateTimeField(auto_now_add=False, auto_now=True)

    class Meta:
        abstract = True

class CommonInfoBaseModel(models.Model):
    name = models.CharField(max_length=128)
    description = models.TextField()
    
    class Meta:
        abstract = True

# В этой модели явно описано только поле bottle_volume, но за счёт наследования
# модель будет содержать и поля 
# created_at, modified_at, name и description:
class BottledMilk(BaseModel, CommonInfoBaseModel):
    bottle_volume = models.IntegerField()

# А тут явным образом описано только поле weight; 
# остальные поля будут также унаследованы от базовых моделей:
class Cheese(BaseModel, CommonInfoBaseModel):
    weight = models.IntegerField()

# Для этой модели нужны поля только одного базового класса:
class Employee(BaseModel):
    first_name = models.CharField(max_length=128)
    second_name = models.CharField(max_length=128)
    role = models.CharField(max_length=128)
 
```

Одну абстрактную модель можно наследовать от другой. При этом наследники абстрактных классов не будут по умолчанию абстрактными. Для этого в модели-наследнике тоже нужно указать атрибут `abstract = True`:

```python
class BaseModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    modified_at = models.DateTimeField(auto_now_add=False, auto_now=True)

    class Meta:
        abstract = True

class CommonInfoBaseModel(BaseModel):
    name = models.CharField(max_length=128)
    description = models.TextField()
    
    class Meta:
        abstract = True 
```

Наследование от абстрактных моделей — хорошая практика, но в работе необходимо следовать здравому смыслу и создавать абстрактные модели лишь в тех случаях, когда они действительно нужны, например — когда в нескольких классах повторяется один и тот же код.

## На заметку

Много интересного про `class Meta` можно [увидеть в документации](https://docs.djangoproject.com/en/3.2/ref/models/options/).

### Задание
В файле _models.py_ приложения **core** создайте абстрактную модель `PublishedModel`. Эта модель должна добавлять в модели-наследники флаг `is_published` со значением по умолчанию `True`.

Импортируйте модель `PublishedModel` в файл _models.py_ приложения **ice_cream** и проведите рефакторинг кода: уберите из моделей `Category`, `Topping`, `Wrapper` и `IceCream` повторяющиеся поля и примените наследование от абстрактной модели.