# Иерархия HTML-документа и наследование стилей

### Что нам стоит DOM построить

В HTML одни теги вкладываются в другие точно так же, как на диске вашего компьютера директории вложены друг в друга. Структуру папок можно отобразить в виде дерева — то же и с элементами в HTML.

Анализируя код, браузер интерпретирует вложенность тегов HTML как древовидную структуру, создавая в памяти **DOM-дерево** (от англ. _Document Object Model_ — «объектная модель документа»).

Сравним код страницы и её DOM-дерево:

Скопировать кодHTML

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <title>Дама сдавала багаж | С.Маршак</title>
  </head>
  <body>
    <header>
      <nav id="top-nav">
      <!-- ... -->
      </nav>
    </header>
    <main>
      <p class="negative">
        Дама сдавала багаж:
      </p>
      <!-- ... -->
    </main>
    <footer>
      <!-- ... -->
    </footer>
  </body>
</html> 
```

DOM-дерево для такого кода:

```
document 
└── html  
    ├── head  
    │   └── title
    └── body
        ├── header
        │   └── nav
        ├── main 
        │   └── p
        └── footer   
```

DOM можно и на картинке нарисовать:

![](https://pictures.s3.yandex.net/resources/S3.2_04_08_1682503167.png)

Каждый элемент на схеме называется **узлом DOM**. DOM-дерево походит на генеалогическое древо, где узлы приходятся друг другу родителями или детьми. Аналогичным языком описывают и отношения между узлами в DOM:

- для узлов `header`, `main` и `footer` родительским (_parent_) узлом будет `body`;
- по отношению друг к другу узлы `header`, `main` и `footer` — это «узлы одного уровня», _siblings_;
- узел `p` будет дочерним (_child_) для узла `main`.

Самый верхний узел, `document`, называется **корневым узлом**.

Термины «кузен» или «шурин» при описании DOM обычно не применяют.

DOM-дерево состоит из узлов разного типа — HTML-элементов, текста, комментариев и других сущностей. Всего насчитывается [12 типов узлов](https://dom.spec.whatwg.org/#node), но для работы с CSS нужны только узлы, образованные из HTML-элементов.

> У каждого узла, за исключением корневого, всегда есть один и только один прямой родитель. У любого HTML-узла может быть сколько угодно потомков.

## Наследование стилей

Работа CSS зависит от структуры DOM. Например, CSS-правила, присвоенные определённому узлу, могут наследоваться всеми его потомками.

Достаточно применить к `body` правила, устанавливающие размер и цвет шрифта...

Скопировать кодCSS

```css
body {
  font-size: 40px;
  color: red;
} 
```

...и большинство вложенных элементов приобретут те же свойства: любой текст, независимо от тега, в который он заключён, будь то `<h1>`, `<h2>` или `<p>`, будет отображён шрифтом красного цвета и размером в 40 пикселей.

Слово _Cascading_ в названии языка (**Cascading** Style Sheets) указывает именно на это **наследование**, **каскадность**.

Обычно наследование применяют там, где нужно задать общие параметры текста (цвет, размер, начертание шрифта).

Основные наследуемые свойства:

|Свойство|За что отвечает|
|---|---|
|font-size|размер шрифта|
|font-family|тип шрифта — семейство, к которому должен относиться шрифт|
|font-style|начертание (например курсив)|
|font-weight|насыщенность|
|color|цвет шрифта|

Это не полный список наследуемых свойств, но пока ограничимся этим.

Есть и свойства, которые не передаются по наследству (всё как у людей).

В основном это параметры позиционирования, размеров, отступов, фона и рамок: они не наследуются дочерними элементами.

| Свойство   | За что отвечает                   |
| ---------- | --------------------------------- |
| background | цвет фона                         |
| border     | цвет и размер обводки             |
| width      | ширина                            |
| height     | высота                            |
| padding    | внутренний отступ вокруг элемента |
| margin     | внешний отступ вокруг элемента    |

Со свойствами `padding` и `margin` традиционно возникает путаница; разницу между ними проще всего показать на картинке.

![](https://pictures.s3.yandex.net/resources/picture2_1676928937.png)

У любого элемента (будь то `div`, `p` или `h1`) есть определённые границы.

Свойство `padding` определяет отступ от этих границ до содержимого элемента (например, от границ элемента `h1` до текста, содержащегося в нём).

Свойство `margin` определяет расстояние до следующего элемента.

Узнать, наследуется свойство или нет, можно [на странице с описанием стандартов CSS](https://developer.mozilla.org/ru/docs/Web/CSS/Reference#%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C).

![](https://pictures.s3.yandex.net/resources/S01_102_1676928952.png)

Предположим, что у вас в коде — `<li class="strange"></li>`, а в стилях для всех `<li>` описан один стиль, а для класса `strange` — другой. Например, так:

Скопировать кодCSS

```css
li {
  color: red;
}
.strange {
  color: blue;
} 
```

В этом случае победа будет присуждена тому селектору, у которого выше **специфичность** и приоритет.

![](https://pictures.s3.yandex.net/resources/21_1676932678.png)

### Специфичность селекторов и конфликт свойств

К одному элементу можно применить несколько CSS-правил, описанных для разных селекторов. Если в этих правилах описаны одинаковые свойства с разными значениями, то возникнет конфликт:

Скопировать кодHTML

```css
...
<style>
  .big-text {
    font-size: 100px;
  }
  #very-big-text {
    font-size: 100500px;
  }
</style>
...
<body>
  <h1 id="very-big-text" class="big-text">
    Большой заголовок большой страницы
  </h1>
</body> 
```

К элементу `h1` применено два конфликтующих правила, определяющих размер шрифта:

- селектор по классу `.big-text` говорит — 100px;
- селектор по идентификатору `#very-big-text` говорит — 100500px.

Для решения таких конфликтов есть понятие **«специфичность селекторов»**.

В общем случае правило такое: чем меньше количество элементов, которые потенциально может выбрать селектор, тем этот селектор **приоритетнее** (специфичнее, весомее).

Селектор по тегу выберет все указанные теги, вне зависимости от того, задан ли им класс или `id`. Селектор по классу может выбрать несколько элементов (ведь в коде может быть несколько тегов с одинаковым значением атрибута `class`). А селектор по идентификатору всегда укажет только на один элемент (ведь `id` в пределах страницы должен быть уникален). Выходит, самый высокий приоритет — у селектора по `id`, а самый низкий — у селектора по тегу.

Можно выделить четыре уровня специфичности селекторов (в порядке повышения приоритета):

- селектор по тегу;
- селектор по классу;
- селектор по ID;
- стиль, описанный _inline_, в атрибуте `style` прямо в HTML-коде.

Поэтому при описанном конфликте к элементу будут применены правила из селектора по `id`: размер шрифта станет неприлично большим — 100500 пикселей.

Может оказаться и так, что к одному элементу применены два селектора с одинаковым приоритетом. В такой ситуации действует правило «какие стили описаны ниже, те и приоритетнее».

```css
...
<style>
  .blue-class {
    color: blue;
  }
  .red-class { <!-- Этот класс описан ниже, чем .blue-class, он приоритетнее -->
    color: red;
  }
</style>
...
<p class="red-class blue-class">
   Текст
</p> 
```

Текст в теге `p` будет красным: описание правил для `.red-class` стоит в коде ниже, чем описание `.blue-class`.

Какого цвета будет шрифт в `p`?

```css
...
<style>
  body{
    color: green;
  }
  p {
    color: black;
  }
  .blue-class {
    color: blue;
  }
  #text-id {
    color: white;
  }
</style>
...
<p id="text-id" class="blue-class" style="color: red;">
   Текст
</p> 
```

Зелёный.

Нет, унаследованный от `body` стиль не будет применён: в списке селекторов есть «козыри» постарше.

Чёрный.

Нет, селектор по тегу проигрывает в этом состязании, самый высокий приоритет не у него.

Голубой.

Селектор по классу старше селектора по тегу, но в коде есть правила, у которых приоритет ещё выше. Ответ неправильный.

Белый.

У селектора по `id` очень высокий приоритет, но в приведённом примере не он самый старший. Правильный ответ не здесь.

Правильный ответ

Красный.

Верно! При прочих равных инлайн-стиль имеет приоритет перед всеми селекторами.