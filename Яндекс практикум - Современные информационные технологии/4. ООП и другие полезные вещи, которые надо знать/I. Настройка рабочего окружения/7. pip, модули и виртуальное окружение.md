Разберёмся на практике, как выглядит работа с виртуальным окружением. Но для начала проверьте, что окружение вашего проекта активировано. После активации виртуального окружения имя этого окружения, как правило, отображается в начале командной строки. Если нет, то активируйте его:

```bash
# Директория, в которой вы должны находиться: ...Dev/first_project.

# Для Windows:
source venv/Scripts/activate

# Для Linux и macOS:
source venv/bin/activate 
```

### Эксперименты с библиотекой pytest

В нашем курсе тестирование домашних работ выполняется при помощи библиотеки **pytest** — это инструмент для создания автоматических тестов и для управления ими. Фактически с помощью pytest пишутся и запускаются программы, которые проверяют правильность работы других программ.

В ходе обучения вы будете устанавливать pytest в виртуальное окружение каждого финального задания. С его помощью вы сможете самостоятельно убедиться в правильности и работоспособности вашего решения.

Сами задания ещё впереди, но уже сейчас можно к ним подготовиться. Потренируемся устанавливать pytest, запускать тесты — и, одновременно, посмотрим на более общую картину: как устанавливаются библиотеки и модули в виртуальное окружение проекта.

### Сторонние библиотеки и модули

Внешние модули и библиотеки расширяют набор готовых инструментов, доступных разработчику. Встроенной библиотеки Python недостаточно для работы — и тут на помощь приходят модули, реализованные, как правило, сторонними разработчиками, а не авторами Python.

Сторонние модули могут реализовать какие-то специализированные инструменты, которых нет в стандартной библиотеке, а могут предлагать улучшенные версии существующих инструментов. Чтобы воспользоваться возможностями из этих модулей, их нужно предварительно установить.

## Как установить

Установить модули можно через специальную программу, она была установлена вместе с Python. Это система управления пакетами Python — **pip**.

Для установки модуля или библиотеки при помощи пакетного менеджера нужно выполнить команду в терминале.

В общем виде эта команда выглядит так:
```bash
pip install <название модуля> 
```

По этой команде менеджер пакетов pip:

- соединится со специальным хранилищем библиотек и модулей — с сайтом [PyPI.org](https://pypi.org/),
- найдёт и скачает запрошенный модуль,
- установит модуль в виртуальное окружение, в котором была выполнена команда `pip install`.

Модули и библиотеки на сайте [PyPI](https://pypi.org/) можно найти и вручную. Документация к пакетному менеджеру **pip** есть [тут](https://pip.pypa.io/en/stable/).

## Установка pytest

В активированное виртуальное окружение проекта _first_project_ установите библиотеку **pytest**. Для этого в терминале можно выполнить команду:
```bash
pip install pytest==7.1.3 
```

По этой команде в виртуальное окружение проекта будет установлена именно та версия библиотеки, которую мы применяем для тестирования домашних заданий.

Если не указывать версию библиотеки — будет установлена самая свежая версия:
```bash
pip install pytest 
```

Новейшая версия вам в работе не понадобится (и даже может привести к ошибкам). Будьте внимательны, устанавливайте **pytest 7.1.3**.

Служебные файлы установленных модулей и библиотек сохраняются в директории _Dev/<project_name>/venv_ — в нашем случае это _Dev/first_project/venv_.

### Обновление менеджера пакетов pip

Возможно, после установки библиотеки вы увидите в терминале сообщение с рекомендацией обновить версию пакетного менеджера pip:

![На скриншоте — интерфейс VS Code. В терминале сообщение: “WARNING: You are using pip version 21.2.4; however, version 23.2.1 is available. You should consider upgrading via the ‘<путь> -m pip install --upgrade pip’  command”.](https://pictures.s3.yandex.net/resources/image_1703769649.png)

Это рекомендация, а не требование. Как и большинство программ, менеджер pip регулярно обновляется. Не пренебрегайте обновлениями: они дадут вам доступ к новым функциям и улучшениям программы, это может упростить работу с пакетами.

Чтобы обновить пакетный менеджер, введите команду:
```bash
# Для Windows:
python -m pip install --upgrade pip

# Для Linux и macOS:
python3 -m pip install --upgrade pip 
```

После обновления можно посмотреть, какие вообще библиотеки установлены в ваше виртуальное окружение:
```bash
pip list 
```

В терминале выведется список установленных модулей и библиотек именно из этого виртуального окружения и их версии, в числе которых должен быть и pytest.

![На скриншоте — интерфейс VS Code. В терминале — перечень пакетов и библиотек с указанием версий, установленных в виртуальное окружение: attrs, iniconfig, packaging, pip, pluggy, py, pytest, setuptools, tomli.](https://pictures.s3.yandex.net/resources/image_1703769694.png)

В этом списке будут и библиотеки, которые вы не устанавливали. Часть из этих библиотек были установлены вместе с виртуальным окружением.

Другая часть — это библиотеки, от которых зависит работа других библиотек: библиотека требуется для библиотеки, которая требуется для третьей библиотеки. Так в одной из теорий мироздания на черепахе стоят слоны, а на спинах слонов лежит Земля. Если для одной библиотеки требуются другие — pip сам найдёт, скачает и установит те библиотеки, которые необходимы.

Все эти библиотеки будут отображены при выполнении команды `pip list`.

## Эксперименты с тестами

В директории проекта создайте два новых файла — _pytest.ini_ и _test_program.py_.

![На скриншоте — интерфейс VS Code. Слева, в области с деревом проекта, выделена кнопка, которая отвечает за создание нового файла.](https://pictures.s3.yandex.net/resources/image_1702631168.png)

У вас должна получиться такая структура файлов:

```tree
Dev/
 └── first_project/
     ├── venv/              <-- Папка виртуального окружения.
     ├── .vscode/           <-- Папка с настройками VS Code (может и не быть).
     ├── practicum.py       <-- Файл с вашей программой.
     ├── pytest.ini         <-- Файл с настройками тестов.
     └── test_program.py    <-- Файл с тестами. 
```

В файле _pytest.ini_ хранятся настройки библиотеки. Скопируйте в него следующий код:
```bash
[pytest]
addopts = -vv -p no:cacheprovider 
```

В файле _test_program.py_ будем хранить сами тесты.

```python
try:
    import practicum
except ImportError:
    raise AssertionError('Модуль `practicum` не обнаружен.')

EXPECTED_FUNC_NAME = 'say_hello'


def test_say_hello_exists():
    assert hasattr(practicum, EXPECTED_FUNC_NAME), (
        f'Функция `{EXPECTED_FUNC_NAME}` не обнаружена в модуле `practicum`')


def test_say_hello_run_without_exceptions():
    try:
        practicum.say_hello()
    except Exception as error:
        raise AssertionError(
            f'При запуске функции `{EXPECTED_FUNC_NAME}` возникло '
            f'исключение: {type(error).__name__}: {error}`'
        ) 
```

Эти тесты проверяют:

- наличие функции с именем `say_hello` в коде из файла _practicum.py_,
- что эта функция запускается без ошибок.

## Запуск тестов

Проверим, как тесты работают на практике. Но сначала смоделируем ситуацию, которая приводит к частой ошибке при запуске тестов.

Переименуйте файл _practicum.py_ например в _practicum2.py_ и, находясь в активированном виртуальном окружении проекта в директории _Dev/first_project_, запустите pytest:
```bash
pytest 
```

Эта команда запустит pytest, а pytest уже сам найдёт и запустит файл с тестами _test_program.py_.

Тесты запустятся, но тестируемый файл они не найдут, о чём и сообщат вам.

```bash
(venv) basov@in-AIR first_project % pytest
=================================== test session starts ====================================
platform darwin -- Python 3.9.10, pytest-7.1.3, pluggy-1.3.0 -- /Users/user/dev/first_project/venv/bin/python3
rootdir: /Users/user/dev/first_project, configfile: pytest.ini
collected 0 items / 1 error                                                                

========================================== ERRORS ==========================================
_____________________________ ERROR collecting test_program.py _____________________________
test_program.py:2: in <module>
    import practicum
E   ModuleNotFoundError: No module named 'practicum'

During handling of the above exception, another exception occurred:
test_program.py:4: in <module>
    raise AssertionError('Модуль `practicum` не обнаружен.')
E   AssertionError: Модуль `practicum` не обранужен.
================================= short test summary info ==================================
ERROR test_program.py - AssertionError: Модуль `practicum` не обранужен.
!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!
===================================== 1 error in 0.04s ===================================== 
```

Такая ошибка может возникать не только из-за отличий в имени, но и, например, если тесты находятся не в той директории.

Переименуйте файл обратно в _practicum.py_ и снова запустите тесты.

```bash
=================================== test session starts ====================================
platform darwin -- Python 3.9.10, pytest-7.1.3, pluggy-1.3.0 -- /Users/user/dev/first_project/venv/bin/python3
rootdir: /Users/user/dev/first_project, configfile: pytest.ini
collected 2 items                                                                          

test_program.py::test_say_hello_exists FAILED                                        [ 50%]
test_program.py::test_say_hello_run_without_exceptions FAILED                        [100%]

========================================= FAILURES =========================================
__________________________________ test_say_hello_exists ___________________________________

    def test_say_hello_exists():
>       assert hasattr(practicum, EXPECTED_FUNC_NAME), (
            f'Функция `{EXPECTED_FUNC_NAME}` не обнаружена в модуле `practicum`')
E       AssertionError: Функция `say_hello` не обнаружена в модуле `practicum`
E       assert False
E        +  where False = hasattr(practicum, 'say_hello')

test_program.py:10: AssertionError
__________________________ test_say_hello_run_without_exceptions ___________________________

    def test_say_hello_run_without_exceptions():
        try:
>           practicum.say_hello()
E           AttributeError: module 'practicum' has no attribute 'say_hello'

test_program.py:16: AttributeError

During handling of the above exception, another exception occurred:

    def test_say_hello_run_without_exceptions():
        try:
            practicum.say_hello()
        except Exception as error:
>           raise AssertionError(
                f'При запуске функции `{EXPECTED_FUNC_NAME}` возникло '
                f'исключение: {type(error).__name__}: {error}`'
            )
E           AssertionError: При запуске функции `say_hello` возникло исключение: AttributeError: module 'practicum' has no attribute 'say_hello'`

test_program.py:18: AssertionError
================================= short test summary info ==================================
FAILED test_program.py::test_say_hello_exists - AssertionError: Функция `say_hello` не об...
FAILED test_program.py::test_say_hello_run_without_exceptions - AssertionError: При запус...
==================================== 2 failed in 0.02s ===================================== 
```

Теперь тесты нашли нужный файл, однако статус **FAILED** напротив каждого теста в итоговом отчёте говорит о том, что оба теста «упали». Дело в том, что тесты ожидают найти в тестируемом коде функцию `say_hello` и запустить её, но её там нет.

Исправим это.

Измените код в файле _practicum.py_ на ожидаемый тестами и снова запустите pytest.

```python
def say_hello():
    print('Привет, Практикум!') 
```

Теперь всё должно пройти гладко!

```bash
=================================== test session starts ====================================
platform darwin -- Python 3.9.10, pytest-7.1.3, pluggy-1.3.0 -- /Users/user/dev/first_project/venv/bin/python3
rootdir: /Users/user/dev/first_project, configfile: pytest.ini
collected 2 items                                                                          

test_program.py::test_say_hello_exists PASSED                                        [ 50%]
test_program.py::test_say_hello_run_without_exceptions PASSED                        [100%]

==================================== 2 passed in 0.00s ===================================== 
```

Напротив каждого успешно пройденного теста должен стоять статус **PASSED**.

Если у вас Windows и русский текст не отображается

## Перенос проекта и файл с зависимостями

Теперь представим, что этот проект вам нужно передать коллегам. Первое решение, которое приходит в голову, — просто скопировать директорию проекта. Однако просто скопировать и передать директорию проекта — не самый хороший вариант.

Количество устанавливаемых библиотек и модулей за время разработки может сильно увеличиться, и директория виртуального окружения может оказаться достаточно «тяжёлой». И что самое неприятное — на разных операционных системах содержимое директории должно быть разным.

Чтобы таких проблем не было, нужно передавать проект без директории виртуального окружения, но с указанием конкретных версий библиотек, необходимых для его работы. Для решения этой задачи разработчики используют файл с **зависимостями.** Как правило его называют _requirements.txt_, хотя название может быть любым.

> Зависимости проекта — это библиотеки и модули, которые необходимы для работы проекта.

Чтобы создать файл, выполните команду в активированном виртуальном окружении проекта _first_project_:
```bash
pip freeze > requirements.txt 
```

После выполнения команды в директории проекта появится новый файл — _requirements.txt_. В этот файл будут построчно записаны имена пакетов и библиотек с указанием версий: всё, что вы устанавливали в виртуальное окружение проекта.

💡 В команде указан символ `>` — он используется для перенаправления [потока вывода](https://docs.python.org/3/library/sys.html?highlight=sys%20stdout#sys.stdout). Без этого знака и последующего имени файла результат выполнения команды будет выведен в терминал, но вам нужно сохранить названия библиотек в файл. Поэтому мы и перенаправляем вывод по умолчанию на запись в файл с указанным именем.

Содержимое файла будет выглядеть приблизительно так:

![На скриншоте — интерфейс VS Code. В рабочей области открыт файл requirements.txt и отображено его содержимое. Это перечень пакетов и библиотек с указанием версий: attrs, iniconfig, packaging, pip, pluggy, py, pytest, setuptools, tomli.](https://pictures.s3.yandex.net/resources/image_1702055821.png)

Чтобы смоделировать установку пакетов из файла _requirements.txt_, удалите текущее виртуальное окружение — введите в терминал две команды:
```bash
# Деактивировать текущее окружение.
deactivate
# Удалить директорию окружения.
rm -r venv 
```

Теперь создайте новое виртуальное окружение и активируйте его.

Какой командой или набором команд вы воспользуетесь, чтобы создать и активировать виртуальное окружение?

```bash
python venv venv
source venv/.../activate 
``` 

```bash
python venv/.../activate 
``` 

Правильный ответ

```bash
python -m venv venv
source venv/.../activate 
``` 

То, что нужно!

После того как новое окружение будет создано, активируйте его и выполните команду:

```bash
pip install -r requirements.txt 
```

Опция `-r` указывает `pip` на то, что следует установить пакеты, перечисленные в файле, имя которого следует сразу за `-r`. В данном случае из файла `requirements.txt`.

Пакетный менеджер построчно считает файл зависимостей и установит указанные в нём библиотеки.

Самое главное о настройке рабочего окружения — [в шпаргалке](https://code.s3.yandex.net/Python-dev/cheatsheets/085-nastroika-rabochego-okruzhenija-shpora/085-nastroika-rabochego-okruzhenija-shpora.html).