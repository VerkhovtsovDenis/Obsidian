При работе над кодом никто не застрахован от ошибок. Задача разработчика — минимизировать число возможных ошибок, а выявленные ошибки найти и исправить.

Одной из причин возникновения проблем в коде может быть ошибка в типах данных.
```python
def we_crash_all(name):
    return 'Привет, ' + name + ', мы всё сломали!'

print(we_crash_all('Наташа'))
```

Хорошая функция, отлично работает, никаких проблем.

Но никто не мешает передать в функцию `we_crash_all()` булеву переменную (разработчик вполне может не учесть возможность такого события):
```python
def we_crash_all(name):
    return 'Привет, ' + name + ', мы всё сломали!'

print(we_crash_all(True))
```

Ошибка! В Python нельзя просто взять и сложить значение типа `str` со значением типа `bool`. Функция ожидала на вход строку, а пришло булево значение.

Python использует **динамическую типизацию**: тип переменной определяется не в момент её объявления, а в момент присвоения значения.

В результате одна и та же переменная в разных местах кода может иметь разный тип:

```python
# Создаём переменную со значением типа string.
item = 'Это строка'
# Выводим тип переменной.
print(type(item))
# В терминал будет выведено: <class 'str'>

# Присваиваем переменной новое значение типа integer.
item = 1234
# Выводим тип переменной.
print(type(item))
# В терминал будет выведено: <class 'int'> 
```

Такая гибкость удобна, но иногда она может привести к непредсказуемым ошибкам.

Другой пример: функция `speak_up()` принимает на вход коллекцию и ожидает, что к этой коллекции можно применить функции `pop()` и `append()`. Функция `append()` работает только со списками, однако нет никаких технических преград тому, чтобы в ходе выполнения программы передать в функцию, например, множество.

Запустите код и посмотрите, что получится:
```python
def speak_up(sentence):
    list.pop(sentence)
    list.append(sentence, '!')
    message = str.join(' ', sentence)
    return message

words = ['Программировать -', 'это', 'просто', '.']

print(speak_up(words))

# Привели список к типу set и присвоили сет переменной words,
# значением которой раньше был список.
words = set(words)

# Повторяем вызов функции speak_up():
print(speak_up(words))
```

Привет, `name`, мы опять всё сломали.

В небольшой программе ошибку легко предотвратить: каждое значение — как на ладони. Но когда в проекте будет взаимодействовать множество функций и переменных, несоответствие типов может стать серьёзной проблемой.

## Type Hints: аннотация типов данных

Чтобы держать типизацию под контролем, применяют **аннотации типов данных** (_type hints_, дословный перевод с английского — «подсказки по типам»). Это явное указание типа ожидаемых данных при объявлении переменных, классов и функций.

```python
# Без аннотации: объявили переменную, 
# а Python сам определил, какой в ней тип данных.
birth_year = 1971

# С аннотацией: объявили переменную и указали, 
# что это переменная только для целых чисел.
birth_year: int = 1971

# Общий синтаксис аннотирования переменных:
<имя переменной>: <принимаемый тип> = <значение> 
```

При выполнении кода Python **игнорирует аннотации** типов и не выдаёт ошибок, даже если типизация нарушена:

```python
# Переменная var_for_bool аннотирована как булева, но в неё передана строка.
var_for_bool: bool = 'Чистая правда, клянусь!' 
```

Python не обратит внимания на это несоответствие и продолжит выполнять код как ни в чём не бывало. Аннотация будет проигнорирована, переменная будет воспринята Python как строка.

## Ну и кому нужны эти Type Hints?

Аннотирование типов не изменяет принцип динамической типизации языка Python: есть ли аннотация, нет ли её — тип переменной в любом случае можно изменить. Следовательно, аннотация типов сама по себе не может защитить от ошибок.

Однако Python не оставляет аннотации типов совсем без внимания: он считывает их и сохраняет в словарь `__annotations__`.

Содержимое этого словаря можно вывести на экран:
```python
# Аннотация переменной name: "это строка".
name: str = 'Наташа'

# Аннотация переменной var_for_bool: "это булева переменная".
var_for_bool: bool = True

# Можно напечатать аннотации переменных:
print(__annotations__)
```

Этот словарь может быть считан и проанализирован сторонними программами, которые специализируются на проверке типизации. Если такая программа-анализатор обнаружит несоответствие, например, типа аргумента, переданного в функцию, и типа, который ожидает функция, то программа уведомит об этом разработчика.

По смыслу работа такой программы похожа на работу линтера, её задача — проверить код и предупредить разработчика, если он пишет что-то не то.

Существует несколько популярных инструментов для проверки типизации:

- [Mypy](http://mypy-lang.org/) — активно развивается при участии Гвидо ван Россума, создателя Python. Это один из наиболее известных инструментов для работы с аннотациями типов в Python.
- [Pyre](https://pyre-check.org/) — отличная альтернатива Mypy.
- [Pytype](http://github.com/google/pytype) — инструмент для анализа типов, разработанный компанией Google.
- [Mypy Type Checker](https://marketplace.visualstudio.com/items?itemName=ms-python.mypy-type-checker) — создан корпорацией Microsoft.

Эти инструменты можно использовать как из командной строки, так и в редакторе кода. Они подсвечивают строки, в которых возможны ошибки, и дают подсказки при написании кода.

Установите [Mypy Type Checker](https://marketplace.visualstudio.com/items?itemName=ms-python.mypy-type-checker) — официальное расширение для VS Code от Microsoft. В редакторе VS Code в левой панели нажмите кнопку _Extensions_, в поисковой строке наберите _mypy type checker_, из результатов поиска выберите расширение **Mypy Type Checker** и установите его (кнопка _Install_).

![На скриншоте — интерфейс VSCode. Скриншот подкрепляет инструкцию описанную ранее.](https://pictures.s3.yandex.net/resources/image_1702056569.png)

Теперь Mypy Type Checker будет постоянно наблюдать за кодом, который вы пишете, а при обнаружении ошибки занервничает и немедленно сообщит о проблеме: подчеркнёт ошибку в коде и покажет детальное описание во вкладке «Проблемы» _(Problems)_.

Сейчас понадобится поле для экспериментов. Создайте в рабочей директории _Dev_ файл с расширением _.py_, откройте его в редакторе кода и разместите в нём код из листинга:

```python
# Аннотируем параметр функции: "значение name должно быть типа str!"
def we_crash_all(name: str):
    return 'Привет, ' + name + ', мы всё сломали!'

print(we_crash_all(True)) 
```

Сохраните изменения.

Расширение Mypy немедленно среагировало: «Обнаружена попытка передать в функцию аргумент с типом данных `bool`, тогда как функция ожидает `str`!»

![На скриншоте — интерфейс VSCode с описанным только что случаем.](https://pictures.s3.yandex.net/resources/image_1702056576.png)

## Аннотирование встроенных типов данных

В простейшем случае аннотация описывает непосредственно ожидаемый тип данных, например `str`, `int`, `float` или `bool`. Можно применять и `None`, «ничего». Например, если функция ничего не возвращает, тип возвращаемых данных указывается как `None`.

### Type Hints для переменных

Переменные в Python обычно аннотируются так:

```python
# Только целочисленные значения.
var_integer: int = 10
# Числа с плавающей точкой (включая целые, можно передать и значение 10).
var_float: float = 10.0
# Логический тип.
var_flag: bool = True
# Строки.
var_string: str = 'я строка' 
```

В Python есть и другой синтаксис аннотирования, вы можете встретить его при работе со старыми проектами. Этот синтаксис устарел, но встречается:

```python
# Вместо аннотации birth_year: int = 1971
# может применяться устаревший вариант, он использовался до Python 3.5.
# Комментарий после объявления переменной - это и есть аннотация типа:
birth_year = 1971  # type: int 
```

### Type Hints для функций

Для функций тоже можно указывать аннотации, например для аргументов и возвращаемого значения:
```python
# def <имя функции>(<аргумент>: <тип>) -> <возвращаемый тип>:

def is_rhomb(a_size: float, b_size: float) -> bool:
    """Принимает на вход длины сторон параллелограмма
       и проверяет, является ли параллелограмм ромбом."""
    
    # Вернёт True или False в зависимости от истинности выражения.
	return a_size == b_size

# Функция print_hi() ожидает строковый аргумент name,
# значение этого аргумента по умолчанию - 'незнакомец'.
# Функция ничего не возвращает, тип возвращаемых данных - None.
def print_hi(name: str = 'незнакомец') -> None:
    print('Привет,' + name + '!')


# Можно напечатать аннотации функций:
print(f'Аннотации для is_rhomb(): {is_rhomb.__annotations__}')

print(f'Аннотации для print_hi(): {print_hi.__annotations__}')
```

### Когда встроенных типов недостаточно

Иногда возникают ситуации, когда переменная может быть либо конкретного типа, либо `None`. В аннотации необходимо указать одновременно два типа данных.

В таких ситуациях на помощь приходит модуль **typing**.

Модуль `typing` в Python предоставляет набор стандартных типов и инструментов для создания более сложных аннотаций.

Рассмотрим некоторые из них:

**Optional.** Используется, когда аргумент функции может быть определённым типом или `None`. Например, если переменная `any_var` может принять целое число или `None`, надо аннотировать её так: `any_var: Optional[int]`. Значение `None` не нужно указывать явным образом.

Например, функция может вернуть данные разного типа, и переменная должна быть аннотирована обоими этими типами:
```python

# Для применения модуля typing нужно импортировать или весь модуль,
# или необходимые типы из него.
from typing import Optional

def greet(name: Optional[str] = 'гость'):
    if not name == 'гость':
    # Если в переменную name передана какая-то строка -
    # функция вернёт приветственную фразу:
        return f'Привет, {name}!'
    # Если же в переменную name ничего не передано 
    # и она приняла значение по умолчанию - функция вернёт Nоne.


# Функция greet() может вернуть строку или None,
# так что надо аннотировать переменную этими двумя типами.
result_no_name: Optional[str] = greet()
print(result_no_name)

result_has_name: Optional[str] = greet('Гвидо')
print(result_has_name)
```

**Union.** Этот тип используется, когда переменная может получить значение одного из нескольких типов.

```python
from typing import Union

# Функция будет успешно работать как с целыми числами,
# так и с десятичными дробями:
def is_rhomb(a_size: Union[int, float], b_size: Union[int, float]) -> bool:
    """Принимает на вход длины сторон параллелограмма
       и проверяет, является ли параллелограмм ромбом."""
    # Вернёт True или False в зависимости от истинности выражения.
    return a_size == b_size

def greet(name='гость'):
    if not name == 'гость':
        return f'Привет, {name}!'

# Переменную, которая готова принять значения типа None и str,
# можно аннотировать и с помощью Union:
result_has_name: Union[str, None] = greet('Гвидо')
```

Модуль `typing` умеет многое, подробно с его возможностями можно познакомиться в [документации](https://docs.python.org/3.9/library/typing.html#special-typing-primitives).

### Что в итоге?

В итоге — ещё один шаг к аккуратному коду! Типизация помогает в работе, защищает от ошибок, упорядочивает код и облегчает его чтение.

Нет повода не отработать новый навык на практике!

> [!done] А практиковаться проще [со шпаргалкой](https://code.s3.yandex.net/Python-dev/cheatsheets/087-trebovanija-k-kodu-shpora/087-trebovanija-k-kodu-shpora.html). Сохраняйте в закладки и вперёд — к задачам!