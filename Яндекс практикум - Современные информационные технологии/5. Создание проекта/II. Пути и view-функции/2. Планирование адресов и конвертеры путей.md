# Планирование адресов и конвертеры путей

У каждого объекта в интернете (у страницы, файла, картинки, каталога) есть уникальный веб-адрес, **URL** (_Uniform Resource Locator_, «унифицированный указатель ресурса»). Чтобы обратиться к нужному объекту — отправляют запрос на URL страницы. Есть два способа указать URL: **абсолютный** путь и **относительный** путь.

## Абсолютные URL

Абсолютный адрес чем-то схож с адресом на конверте. Если в адресе указаны все данные — страна, город, улица, дом, квартира, то это письмо дойдёт по адресу, откуда его ни отправляй, хоть с соседней улицы, хоть с другой стороны земного шара.

Абсолютный URL содержит все сведения, необходимые для получения запрошенной информации, и в общем виде выглядит так:

`<схема или протокол>://<название сервера>/<путь>`

|Имя|Описание|
|---|---|
|схема или протокол|Указывает способ доступа к ресурсу. Например, протокол http или https.|
|название сервера|Указывает имя компьютера, на котором находится ресурс. Это может быть название домена, домен с www или просто IP-адрес.|
|путь|Указывает последовательность каталогов через /, ведущих к целевому объекту.|

Пример абсолютного адреса — страница документации Django:

`https://docs.djangoproject.com/en/3.2/topics/http/urls/`.

- _https_ — протокол;
- _docs.djangoproject.com —_ доменное имя;
- _/en/3.2/topics/http/urls/ —_ путь.

А всё вместе, `https://docs.djangoproject.com/en/3.2/topics/http/urls/,` — это абсолютный адрес. Согласно [философии дизайна адресов Django](https://docs.djangoproject.com/en/3.2/misc/design-philosophies/#url-design) адреса принято заканчивать слешем.

## Относительные URL

Для доступа к страницам в пределах одного домена применяют **относительные адреса** (относительные URL). Они составляются **относительно** того адреса, с которого отправляется запрос. В относительный адрес не включается адрес домена, а в некоторых случаях — и часть пути.

Например, со страницы с абсолютным адресом `https://docs.djangoproject.com/en/3.2/topics/` можно отправить

- запрос по относительному URL _install/_ — и получить доступ к странице с абсолютным адресом `https://docs.djangoproject.com/en/3.2/topics/install/`;
- запрос по относительному адресу _../_ (две точки — это «на один уровень вверх», точно как в переходе по директориям в консоли) — и получить доступ к странице `https://docs.djangoproject.com/en/3.2/`.

Продолжим аналогию с письмами. Если нужно доставить письмо в пределах одного дома, из одной квартиры в другую, — адрес дома указывать не требуется; в поле «Куда» можно написать так: «на два этажа выше моей квартиры, по коридору направо, последняя дверь слева».

Если в ту же квартиру отправлено письмо с того же этажа, где она расположена, — относительный адрес будет ещё короче: «правый коридор, последняя дверь слева».

А относительный адрес для письма в соседний подъезд будет чуть иным: «из моей квартиры вниз, выйти из подъезда, зайти в соседний, там на третий этаж и налево; дверь справа в конце этажа». Ни в том, ни в другом относительном адресе нет ни названия города, ни даже номера дома: он просто не нужен.

Выгода от применения относительных адресов проста и очевидна. Как правило, проект разрабатывается на локальном компьютере, на домене `http://127.0.0.1`; после завершения работы проект публикуют на каком-то реальном домене в интернете. Если для адресации в пределах проекта применены относительные URL — при переносе проекта с компьютера на рабочий домен адреса в проекте менять не придётся: ведь относительные адреса не зависят от имени домена.

### Маршрутизатор в Django

Адреса, которые будут доступны на сайте, могут быть любыми; обычно их придумывают при составлении `техзадания` к проекту. В ТЗ описывают, какая информация будет доступна при обращении к тому или иному адресу.

![](https://pictures.s3.yandex.net/resources/1_1683919704.png)

Маршрутизатор — это список адресов, на запрос к которым сервер готов дать ответ. Блок «View-функция» — это **обработчик запросов**. Такие функции (их называют **view-функции**) генерируют ответ и отправляют его пользователю.

> В маршрутизаторах применяют относительные адреса.

В качестве адресов могут выступать любые строки, но обычно используют английские слова в нижнем регистре, разделяя их знаками `-` или `_`. Лучше давать такие адреса, чтобы по ним пользователь мог понять, какая информация содержится на странице.

Например, из адреса `https://practicum.yandex.ru/backend-developer/` понятно, что страница связана с профессией «бэкенд-разработчик».

### Связь URL и обработчика

Для связи адреса запроса и обработчика применяется функция `path()`. Она принимает обязательные параметры `route` и `view`:

- **route** — шаблон обрабатываемого адреса, это строка-образец, с которой сравнивается полученный запрос. По-русски её называют **маршрут** или **роут**.
- **view** — функция-обработчик: если запрошенный URL совпадает с **route**, вызов будет перенаправлен в указанную view-функцию (view-функции в Django хранят в файле _views.py_).

Когда Django получает запрос к определённому адресу, маршрутизатор вызывает обработчик, связанный с запрошенным адресом. Этот обработчик подготавливает нужные данные для ответа.

Логика проста: если пользователь обращается к относительному адресу _/about/_ — должна быть вызвана view-функция, в которой разработчик опишет, как сгенерировать и отправить пользователю страницу «О компании». Значит, маршрут _/about/_ должен быть связан с этой view-функцией.

В общем виде вызов функции выглядит так:

```python
path('относительный_адрес', <имя обработчика>)

# Например:
path('about/', views.about) 
# Если пользователь обратится к относительному адресу /about/,
# будет вызвана функция about() из файла views.py 
```

Любой Django-проект, как правило, обрабатывает множество адресов; каждому адресу должен соответствовать вызов функции `path()`.

В Django список путей обычно хранится в файле _urls.py:_

```
acme_project/             <-- Рабочая папка Django-проекта
├── acme_project/         <-- Папка с настройками проекта
|   ├── __init__.py
|   ├── asgi.py
|   ├── settings.py
|   ├── urls.py            <-- Файл с адресами
|   └── wsgi.py
└── manage.py
... 
```

Django будет искать главный файл _urls.py_ по адресу, который указан в константе `ROOT_URLCONF` в файле _settings.py_. Конечно, вы можете изменить этот адрес и сохранить список адресов где угодно, но коллеги будут разочарованы нестандартным подходом: им придётся тратить время и разбираться, куда вы дели этот список и зачем вам это понадобилось.

### Список адресов

Список путей в Django хранится в списке `urlpatterns`. В воображаемом интернет-магазине компании ACME список `urlpatterns` мог бы содержать такие строки:

```python
# Файл urls.py

...

urlpatterns = [
    ...
    # Обрабатываем запрос к главной странице проекта:
    # у неё нет относительного адреса, поэтому вместо шаблона адреса 
    # - пустая строка.
    path('', <имя view-функции, отображающей главную страницу>),

    # Обрабатываем запрос к странице со списком товаров:
    # если получен запрос 'catalog/',
    # будет вызвана функция-обработчик, которая покажет список доступных товаров.
    path('catalog/', <имя view-функции, отображающей список товаров>), 
] 
```

> При получении запроса Django читает список `urlpatterns` **сверху вниз**, пока не найдёт первое подходящее совпадение запрошенного адреса с шаблоном в списке.

Если запрошенный URL не обнаружился в списке заготовленных адресов, пользователю отправляется страница с сообщением об ошибке 404 Page Not Found, «страница не найдена».

>[!question] Вопрос Если в проекте ACME запрос сделан к **относительному адресу** _nice/perfect/beautiful/_, какая view-функция будет вызвана? 
>>[!fail] `<view-функция-один>` 
>>Нет, эта функция будет вызвана, если относительный адрес в запрошенном URL равен пустой строке, то есть при запросе к главной странице домена. 
>
>>[!fail] `<view-функция-два>` 
>>Нет, шаблон адреса `'not'` при таком запросе не сработает. 
>
>>[!success] `<view-функция-три>` 
>>Nice ответ, просто perfect! Относительный адрес запрошенного URL совпадает с тем шаблоном, которому соответствует вызов `<view-функция-три>`. 
>
>>[!fail] `<view-функция-четыре>` 
>>Не perfect, ответ неправильный. Эта функция была бы вызвана при обращении к адресу _/perfect/_. 
>
>>[!fail] `<view-функция-пять>` 
>>Ответ неправильный: эта функция была бы вызвана при обращении к адресу _/nice/_. 
>
>>[!fail] `<view-функция-шесть>` 
>>Нет, эта функция была бы вызвана при обращении к адресу _/nice/perfect/_.``
>

```python
<<<<<<< HEAD:Education/Яндекс практикум - Современные информационные технологии/Создание проекта/II. Пути и view-функции/2. Планирование адресов и конвертеры путей.md

=======
>>>>>>> 335713cc75f2671df7efb320d83d056298be94bb:Яндекс практикум - Современные информационные технологии/Создание проекта/II. Пути и view-функции/2. Планирование адресов и конвертеры путей.md
# Файл urls.py
...
urlpatterns = [
    path('', <view-функция-один>),
    path('not/', <view-функция-два>),
    path('nice/perfect/beautiful/', <view-функция-три>),
    path('perfect/', <view-функция-четыре>),
    path('nice/', <view-функция-пять>),
    path('nice/perfect/', <view-функция-шесть>)
] 
```

### Переменные пути

Редко бывает так, чтобы в магазине был только один товар. Значит, придётся описывать целую серию адресов: `'catalog/1/'`, `'catalog/2/'`, `'catalog/3/'` ... `'catalog/100500/'`. Выглядит странно и нерационально.

При обработке однотипных адресов уникальную часть адреса можно сохранять в переменную и передавать её во view-функцию в качестве аргумента. Для этого в шаблоне адреса имя переменной заключают в треугольные скобки `<>`.

```python
# catalog/urls.py
...

urlpatterns = [
    ...
    # Страница с информацией о товаре
    # с уникальным номером, который равен pk.
    # Имя pk (primary key) — традиционное имя для переменной, 
    # в которой передаётся идентификатор объекта в базе данных.
    path('catalog/<pk>/', views.product_detail),
] 
```

Теперь при получении запросов к относительным адресам вида

- _catalog/1/_
- _catalog/100500/_
- _catalog/iron_carrot/_
- _catalog/любая_строка/_

будет вызываться view-функция `product_detail()` из файла _views.py_.

Во view-функцию будет передан обязательный аргумент, в котором, в зависимости от запрошенного URL, будет содержаться значение `1`, `100500` или `iron_carrot`; в функции эта переменная может быть применена для создания ответа.

### Конвертеры пути

Функция `path()` всегда получает URL в виде строки, но при обработке запроса бывает важно знать, можно ли преобразовать ту или иную часть пути в определённый тип данных.

Например,

- при запросе к адресу _catalog/new/_ должна вернуться страница с новыми товарами,
- при запросе к адресу _catalog/popular/_ должна вернуться страница с популярными товарами,
- при запросе к адресу _catalog/128/_ должна вернуться страница товара с идентификатором 128; то же и с другими числами.

В такой ситуации маршрут `path('catalog/<pk>/', views.product_detail)` не подойдёт.

Требуется проверка — какого рода символы переданы в переменной:

- если адрес устроен так: `catalog/<цифры>/` — вызываем view-функцию `product_detail()`;
- если адрес устроен так: `catalog/<буквы>/` — вызываем какую-то другую view-функцию.

Содержимое переменной можно проверить с помощью **конвертеров пути** (англ. _path converters_). В конвертере указывают, должно ли ожидаемое значение переменной приводиться к числу или к строке.

Вот список наиболее востребованных конвертеров:

- `str` — ожидает непустую строку, состоящую из любых символов, за исключением разделителя пути `'/'`.
    
    ```python
      path('about/<str:name>/', views.stuff_info),
      # Этот шаблон сработает, если будут запрошены адреса вида
      # about/company/, about/15/ или about/vacancy/
    ```
    
    Если конвертер не указан явно, то по умолчанию будет применён именно `str`: шаблон адреса `<name>/` идентичен шаблону `<str:name>/`.
    
- `int` конвертирует значение переменной в ноль или в целое положительное число.
    
    ```python
      path('catalog/<int:pk>/', views.product_detail),
      # Этот шаблон сработает, если будут запрошены адреса вида
      # catalog/1/, catalog/100/, catalog/100500/.
      # А при запросе к адресу catalog/iron_carrot/ 
      # функция product_detail() не будет вызвана.
       
    ```
    
- `slug` ожидает строку из цифр, букв латиницы и символов `-` и `_`.
    
    Обычно слаг используют для создания человекочитаемых URL. Адреса с применением slug любят и люди (знающие английский), и поисковые роботы.
    
    ```python
      path('article/<slug:category>/', views.article_list_by_category),
      # Этот шаблон сработает, если будут запрошены адреса вида
      # article/chto-takoe-slug/, 
      # article/za-chto-mne-eto/, 
      # article/backend_the_best-part_2/.
      
      # Запрос к адресу article/chto-takoe-slug/part-2/ не сработает: 
      # слеш / не входит в набор символов, допустимых в slug.
       
    ```
    

Можно создать и собственный конвертер пути. Например, [конвертер, который будет принимать только четырёхзначное число и игнорировать любые другие параметры](https://docs.djangoproject.com/en/3.2/topics/http/urls/#registering-custom-path-converters).

Пользователь отправил запрос к **относительному URL** _/hello_world/._ Сработает ли view-функция `maks_karpov()`, если список адресов в проекте описан так:

```python
# Файл urls.py

...
urlpatterns = [
    path('<str:filter>/hello_world/', views.maks_karpov),    
] 
```

Да, при обращении к этому URL будет вызвана функция `maks_karpov()`.

Нет, ошибка. Шаблон ожидает путь вида _/<какая-то строка>/hello_world/_. Запросы к остальным URL (включая и приведённый в условии) будут проигнорированы.

Правильный ответ

Нет, при обращении к этому URL функция `maks_karpov()` не будет вызвана.

Верно. Шаблон ожидает путь вида _/<какая-то строка>/hello_world/_. Запросы к остальным URL (включая и приведённый в условии) будут проигнорированы.

### Конфликты адресов: кто сверху, тот и главный

Django читает список `urlpatterns` сверху вниз и вызывает обработчик из первого же `path()`, в котором шаблон адреса совпадёт с запросом. Поэтому могут возникать коллизии.

Например, при описанной ниже структуре view-функция `alan_turing()` никогда не будет вызвана: первый шаблон будет перехватывать все запросы к URL вида _page/_.

```python
...
urlpatterns = [
    path('page/', views.maks_karpov),    
    path('page/', views.alan_turing),
] 
```

Похожая неприятность случится и в таком маршрутизаторе:

```python
...
urlpatterns = [
    path('page/<int:pk>/', views.maks_karpov),    
    path('page/1/', views.alan_turing),
] 
```

Первый `path()` перехватит и обработает все адреса вида _page/<число>/_, в том числе и адрес _page/1/_. В результате функция `alan_turing()` никогда не будет вызвана.

При планировании структуры адресов эту особенность стоит учитывать.

Ещё одна потенциальная возможность конфликтов состоит в том, что при разворачивании проекта в Django автоматически создаётся адрес вида _admin/_ — это адреса «админ-зоны» проекта. Во избежание конфликтов лучше не создавать собственных адресов, начинающихся с этой строки.

В списке `urlpatterns` Django-проекта задан единственный шаблон:

```python
# Файл urls.py

...
urlpatterns = [
    path('hamsters/<slug:category>/', views.strange_hamsters_list),
] 
```

При запросе к какому URL будет вызвана функция `strange_hamsters_list()`?

Правильный ответ

_/hamsters/flying/_

Верно, запрос к категории «летающие хомячки» будет обработан функцией `strange_hamsters_list()`.

_/hamsters/_

Нет, в ответ на запрос к этому URL вернётся ошибка 404 «Страница не найдена»: чтобы сработала функция `strange_hamsters_list()`, в URL после _hamsters/_ обязательно должна быть строка в формате `slug`.

_/dancing/hamsters/_

Правильный ответ

_/hamsters/lets_dance/_

Отлично, вы не попались в ловушку и выбрали один из правильных ответов. Строка с символом `_` — это строка, которая соответствует формату `slug` (ведь `slug` — это строка, которая может включать буквы латиницы, цифры и символы `_` и `-`).

_/hamsters/sing.sing.sing/_

Нет, строка _sing.sing.sing_ не соответствует формату slug, ведь slug не может содержать точки. Значит, ответом на такой запрос будет Error 404.

Список адресов в проекте теперь выглядит так:

```python
...
urlpatterns = [
    path('admin/<int:pk>/', views.admin_detail),
    path('<slug:category_slug>/', views.item_category),
    path('admin/', views.admin),
] 
```

Пользователь отправил запрос на URL _/admin/._ Какая view-функция будет вызвана:

Функция `admin_detail()` из файла _views.py_.

Нет, вызванный URL не соответствует шаблону `'admin/<int:pk>/'`, ведь этот шаблон ожидает число после строки _admin/_, а в запросе этого числа нет.

Функция `admin()` из файла _views.py_.

Шаблон `'admin/'` идеально соответствует запрошенному адресу, но функция `admin()` не будет вызвана: выше в списке есть ещё один шаблон, соответствующий запрошенному URL: `'<slug:category_slug>/'`. Именно этот шаблон «перехватит» запрос (потому что Django читает список `urlpatterns` сверху вниз); будет вызвана функция `item_category()`.

Правильный ответ

Функция `item_category()` из файла _views.py_.

Совершенно верно. В списке есть два шаблона, которым соответствует запрос; сработает тот шаблон, который выше в списке.

Ещё раз изменим маршрутизатор в многострадальном проекте acme_project, теперь он описан так:

```python
...
urlpatterns = [
    path('<slug:category>/', views.product_category_slug),
    path('<str:category>/', views.product_category_str),
    path('<int:category>/', views.product_category_int),
] 
```

При каком из запросов будет вызвана view-функция `product_category_int()`?

_/утюг/_

Нет, этот запрос будет обработан функцией `product_category_str()`. Шаблон `'<str:category>/'` ожидает набор любых символов после имени домена, вот он и перехватит запрос.

Неправильный ответ

_/152/_

Нет, этот запрос будет обработан функцией `product_category_slug()`: цифры входят в набор символов, разрешённых в `slug`, поэтому сработает шаблон `'<slug:category>/'` (он в списке стоит выше, чем `'<int:category>/'`).

_/iron/_

Нет, этот запрос будет обработан функцией `product_category_slug()`.

Тоже правильный ответ

Ни один из перечисленных запросов не будет обработан функцией `product_category_int()`.

Шпаргалка
Перечень адресов хранят в файлах _urls.py_ в списке `urlpatterns`.

Разработчик сам придумывает адреса, которые будет обрабатывать приложение.

Django читает список `urlpatterns` сверху вниз и вызывает обработчик из первого же `path()`, в котором шаблон адреса совпадёт с запросом.

Запросы к адресам, которых нет в _urls.py_, вернут ошибку 404 Page not found.

В шаблонах для однотипных адресов можно применять переменные и конвертеры пути.

```python
urlpatterns = [
    path('catalog/<pk>/', views.product_detail),
] 
```

Популярные конвертеры, определяющие тип ожидаемых данных:

- `str` — ожидает любую непустую строку, исключая разделитель пути `'/'`.  
    Если в параметрах пути конвертер не указан явно, то по умолчанию будет применён именно конвертер `str`: шаблон адреса `<username>/` идентичен шаблону `<str:username>/`.
- `int` — ожидает ноль или любое целое положительное число: `<int:pk>/`.
- `slug` ожидает строку из латинских букв, цифр и символов `-` и `_`. `<slug:category_slug>/`.