# HTML в Django: шаблоны веб-страниц

Основы HTML и CSS позади, самое время вернуться в мир бэкенда.

Магазин _acme.not_ уже научился реагировать на запросы и возвращать текстовую строку:

```python
# homepage/views.py
from django.http import HttpResponse

# Главная страница.
def index(request):    
    return HttpResponse('Главная страница')
 
```

Если view-функция может вернуть клиенту текстовую строку, то почему бы ей не вернуть HTML, ведь это тоже текстовая строка!

Строка будет большая, так что заключим её в тройные кавычки — в Python такое обрамление позволяет разбивать длинный текст построчно (подробности есть [в документации](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str)).

```python
# homepage/views.py
from django.http import HttpResponse

# Главная страница
def index(request):
    html_content = '''
    <!DOCTYPE html>
    <html lang="ru">
      <head>
        <title>ACME</title>
      </head>
      <body>
        <h1>Главная страница</h1>
      </body>
    </html>
    '''
    return HttpResponse(html_content) 
```

![](https://pictures.s3.yandex.net/resources/S02_03_9_1676929345.png)

С технической точки зрения этот подход отлично работает, но писать код будет неудобно. HTML придётся писать прямо среди кода на Python, файл с кодом раздуется. Фронтендер и бэкендер будут вынуждены работать в одном файле, фронтендеру будет мешать Python, а бэкендеру — HTML.

### HTML — отдельно, Python — отдельно

Решение проблемы есть: HTML-код выносят в отдельные файлы (их называют **HTML-шаблонами**).

```html
<!-- homepage/index.html -->
<!DOCTYPE html>
<html lang="ru">
  <head>
    <title>ACME</title>
  </head>
  <body>
    <h1>Главная страница</h1>
  </body>
</html> 
```

Чтобы в ответе на запрос Django мог вернуть HTML-код, шаблоны подключают через **загрузчик** `loader`.

```python
from django.http import HttpResponse
# Импортируем загрузчик.
from django.template import loader

def index(request):
    # Подключаем HTML-файл.
    template = loader.get_template('homepage/index.html')
    # Передаём в объект HttpResponse 
    # HTML-код из загруженного файла, объект запроса request;
    # и возвращаем этот объект.
    return HttpResponse(template.render({}, request)) 
```

В результате в ответ на запрос к главной странице вернётся HTML-код из файла _homepage/index.html_.

### Пиши, сокращай

Для работы с шаблонами разработчики Django придумали сокращённый синтаксис: view-функция возвращает функцию `render()`, в которую передаётся объект запроса `request` и адрес HTML-шаблона.

Загрузка шаблона и создание объекта HttpResponse убраны «под капот», функция `render()` сама выполнит все эти операции.

Скопировать кодPYTHON

```python
# Импортируем функцию render()
from django.shortcuts import render

def index(request):
    template_name = 'homepage/index.html'
    return render(request, template_name) 
```

> **Рендеринг** (англ. _rendering_, «визуализация») — это превращение исходного кода в результат, который видит пользователь. Например, 3D-мультипликаторы в программах трёхмерной графики создают персонажей и эффекты, а потом, после рендеринга исходных файлов, получается видео. В Django после рендеринга создаётся объект HttpResponse, в который передан HTML-код. При рендеринге в HTML-шаблон можно встраивать данные из view-функции.

Посмотреть, как функция `render()` проделывает этот фокус, можно [в коде](https://docs.djangoproject.com/en/3.2/topics/http/shortcuts/) [django.shortcuts](https://github.com/django/django/blob/main/django/shortcuts.py). Функция `render()` упрощает код, в дальнейшем мы будем работать именно с ней.

## Где хранить шаблоны

Шаблонов в проекте получается много: практически для каждой view-функции по шаблону. И всё это надо как-то хранить. Если хранить шаблоны вместе, будет просто куча файлов, но Django — это «фреймворк для перфекционистов с дедлайном». Разводить бардак тут не принято.

Есть две традиционные схемы хранения шаблонов: на уровне приложения и на уровне проекта.

## Хранение шаблонов на уровне приложения

**В директориях приложений** создают папки _templates/имя_приложения/_ и там хранят шаблоны, используемые в приложении. Такой порядок хранения шаблонов называют «на уровне приложения».

Если следовать этой схеме, то шаблоны проекта ACME должны размещаться так:

```
...
├── acme_project/                  <-- Папка с настройками проекта
├── catalog/                       <-- Папка приложения catalog
│   ├── templates/                 <-- Директория для шаблонов
│   │   └── catalog/                 <-- Директория шаблонов приложения catalog
│   │       ├── product_detail.html  <-- Шаблон для отображения товара
│   │       └── product_list.html    <-- Шаблон для отображения списка товаров
│   ├── __init__.py
│   ├── admin.py   
│   ├── apps.py   
│   ├── models.py   
│   ├── test.py
│   ├── urls.py
│   └── views.py
├── homepage/                     <-- Папка приложения homepage
│   ├── templates/                <-- Директория для шаблонов
│   │   └── homepage/             <-- Директория шаблонов приложения homepage
│   │       └── index.html        <-- Шаблон главной страницы
│   └── ...                       <-- admin.py apps.py urls.py views.py и прочее
└── manage.py 
```

> Идея создания ещё одной папки с именем приложения внутри директории _templates/_ выглядит странно, но это не опечатка. Если в разных приложениях будут HTML-шаблоны с одинаковыми названиями, без этой дополнительной директории может возникнуть конфликт имён.

## Хранение шаблонов на уровне проекта

При такой системе **в корневой директории проекта** создаётся папка _templates/_, в ней — директории, названные по именам приложений, и уже в них хранятся шаблоны, относящиеся к приложениям проекта. Такой порядок хранения шаблонов называют «на уровне проекта».

Согласно этому подходу шаблоны приложения **catalog** должны лежать в директории _templates/catalog/_:

```
...
├── acme_project/             <-- Папка с настройками проекта
├── catalog/                  <-- Папка приложения catalog
├── homepage/                 <-- Папка приложения homepage
├── templates/                <-- Отдельная директория для шаблонов
│   ├── catalog/                  <-- Директория шаблонов приложения catalog
│   │   ├── product_detail.html   <-- Шаблон для отображения товара
│   │   └── product_list.html     <-- Шаблон для отображения списка товаров
│   └── homepage/                 <-- Директория шаблонов приложения homepage
│       └── index.html            <-- Шаблон для главной страницы
└── manage.py 
```

Удобно и наглядно.

Выбор схемы зависит от задачи.

- Если приложение планируется использовать многократно, как пакет (с возможностью установки через pip), — шаблоны хранят на уровне приложения. В документации [об этом тоже сказано](https://docs.djangoproject.com/en/3.2/intro/reusable-apps/), загляни.
- В остальных случаях удобнее работать с шаблонами на уровне проекта. В «Анфисе» так и поступим.

### Настройки шаблонизатора Django

Разработчик должен указать фреймворку, где следует искать шаблоны и как с ними работать. Все эти настройки хранятся в списке `TEMPLATES` в файле `settings.py`.

- `BACKEND`: под этим ключом указывается, какой шаблонизатор используется в проекте. Самые популярные шаблонизаторы, использующиеся в Django-проектах, — это `Jinja2` и Django Template Language (DTL). По умолчанию в Django подключён **DjangoTemplates**. С ним мы и работаем.
- `DIRS`: здесь указывается список директорий, где Django будет искать шаблоны. При развёртывании Django-проекта создаётся константа `BASE_DIR`, в которой хранится адрес рабочей директории. Чтобы задать адрес директории с шаблонами, добавим к пути `BASE_DIR` вложенную папку `templates`.
- `APP_DIRS` показывает, нужно ли искать шаблоны в папках приложений.

Вот список `TEMPLATES` с настройками хранения шаблонов на уровне проекта:

```python
# acme_project/settings.py
# Адреса папок с шаблонами можно вынести в отдельные константы,
# код станет более читабельным.
TEMPLATES_DIR = BASE_DIR / 'templates'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        # Указываем, в каких директориях искать HTML-шаблоны.
        'DIRS': [TEMPLATES_DIR],

        # Оставляем True: шаблоны приложений будут искаться 
        # не только на уровне проекта, но и в директориях приложений.
        # Это необходимо для работы 
        # встроенных приложений (например админки).
        'APP_DIRS': True, 
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ]
        },
    }
] 
```

Чтобы ваш код в шаблонах и на обычных HTML-страницах выглядел профессионально и аккуратно — сохраните [ссылочку на шпаргалку Правила оформления HTML и шаблонов](https://code.s3.yandex.net/Python-dev/cheatsheets/025-django-pravila-oformlenija-html-i-shablonov-shpora/025-django-pravila-oformlenija-html-i-shablonov-shpora.html).

Со шпаргалкой проще, чем без неё!