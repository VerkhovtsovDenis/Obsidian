# Объединение таблиц: JOIN

Нарастим базу данных: соберём в неё таблицы **video_products** и **product_types**; добавим таблицу **slogans** (рекламный девиз или ударная фраза из фильма).

Записи из таблицы **video_products** будут ссылаться на слоганы через необязательную связь один к одному: у фильма может и не быть слогана.

![](https://pictures.s3.yandex.net/resources/image_1710436594.png)

![](https://pictures.s3.yandex.net/resources/image_1710436602.png)

![](https://pictures.s3.yandex.net/resources/image_1710436610.png)

![](https://pictures.s3.yandex.net/resources/S02_233_1685551291.png)

[Вот эта база](https://code.s3.yandex.net/backend-developer/learning-materials/db_video_type_slogan.sqlite); берите, подключайтесь и экспериментируйте!

## Получаем связанные данные из таблиц

Получить из нескольких таблиц связанные друг с другом записи — логичная и востребованная задача: иначе нет смысла связывать таблицы.

Попробуем получить из таблицы **video_products** все записи и для каждой из них — слоган, привязанный к ней через `slogan_id`.

Для начала посмотрим, что вернёт запрос одновременно к двум таблицам:

```python
import sqlite3
con = sqlite3.connect('db_video_type_slogan.sqlite')
cur = con.cursor()
results = cur.execute('''
    SELECT *
    FROM video_products, 
         slogans;
''')
for result in results:
    print(result)

con.close() 
```

Запрос вернул результирующую таблицу, включающую все столбцы обеих запрошенных таблиц БД:

`video_products.id` | `video_products.title` | `video_products.type_id` | `video_products.slogan_id` | `slogans.id` | `slogans.slogan_text`

```python
(1, 'Безумные мелодии Луни Тюнз', 2, None, 1, "For Three Men The Civil War Wasn't Hell. It Was Practice!")
(1, 'Безумные мелодии Луни Тюнз', 2, None, 2, "This isn't the movies anymore")
(1, 'Безумные мелодии Луни Тюнз', 2, None, 3, 'Tonight on Murder She Wrote')
(1, 'Безумные мелодии Луни Тюнз', 2, None, 4, "I'll be back")
(2, 'Весёлые мелодии', 2, None, 1, "For Three Men The Civil War Wasn't Hell. It Was Practice!")
(2, 'Весёлые мелодии', 2, None, 2, "This isn't the movies anymore")
(2, 'Весёлые мелодии', 2, None, 3, 'Tonight on Murder She Wrote')
(2, 'Весёлые мелодии', 2, None, 4, "I'll be back")
(3, 'Хороший, плохой, злой', 3, 1, 1, "For Three Men The Civil War Wasn't Hell. It Was Practice!")
(3, 'Хороший, плохой, злой', 3, 1, 2, "This isn't the movies anymore")
(3, 'Хороший, плохой, злой', 3, 1, 3, 'Tonight on Murder She Wrote')
(3, 'Хороший, плохой, злой', 3, 1, 4, "I'll be back")
(4, 'Последний киногерой', 3, 2, 1, "For Three Men The Civil War Wasn't Hell. It Was Practice!")
(4, 'Последний киногерой', 3, 2, 2, "This isn't the movies anymore")
(4, 'Последний киногерой', 3, 2, 3, 'Tonight on Murder She Wrote')
(4, 'Последний киногерой', 3, 2, 4, "I'll be back")
(5, 'Она написала убийство', 4, 3, 1, "For Three Men The Civil War Wasn't Hell. It Was Practice!")
(5, 'Она написала убийство', 4, 3, 2, "This isn't the movies anymore")
(5, 'Она написала убийство', 4, 3, 3, 'Tonight on Murder She Wrote')
(5, 'Она написала убийство', 4, 3, 4, "I'll be back") 
```

В результирующую выборку включены все поля объединяемых таблиц; **к каждой** записи из **video_products** присоединена **каждая** запись из **slogans**.

На математическом языке это называется «декартово произведение множеств» (или [«прямое произведение множеств»](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)).

Выглядит не очень практично, но ведь эту выборку можно отфильтровать!

Отфильтруем декартово произведение с помощью `WHERE`. Оставим только те строки, в которых значение поля `slogan_id` в таблице **video_products** равно значению `id` в таблице **slogans** :

```sql
SELECT *
FROM video_products, 
     slogans
WHERE video_products.slogan_id = slogans.id; 
```

Результирующая выборка будет такой:

![](https://pictures.s3.yandex.net/resources/S02_13_2_1678066375.png)

Напечатаем результат из Python:

```python
(3, 'Хороший, плохой, злой', 3, 1, 1, "For Three Men The Civil War Wasn't Hell. It Was Practice!")
(4, 'Последний киногерой', 3, 2, 2, "This isn't the movies anymore")
(5, 'Она написала убийство', 4, 3, 3, 'Tonight on Murder She Wrote') 
```

Для пущей красоты можно показать только полезные столбцы:

```sql
SELECT video_products.title,
       slogans.slogan_text
FROM video_products, 
     slogans
WHERE video_products.slogan_id = slogans.id; 
```

Тогда результат будет таким:

```python
('Хороший, плохой, злой', "For Three Men The Civil War Wasn't Hell. It Was Practice!")
('Последний киногерой', "This isn't the movies anymore")
('Она написала убийство', 'Tonight on Murder She Wrote') 
```

## JOIN

Конструкция `FROM video_products, slogans` соединяет таблицы, а `WHERE` — фильтрует получившуюся выборку.

По стандарту SQL92 принято отделять фильтрацию от условий соединения таблиц с помощью инструкции `JOIN` (англ. «соединять»):

```sql
-- Верни все поля
SELECT *
-- из таблицы video_products
FROM video_products
-- ...но перед этим присоедини записи из таблицы slogans так, чтобы
-- в записях значения полей video_products.slogan_id и slogans.id были равны.
JOIN slogans ON video_products.slogan_id = slogans.id; 
```

Результат:

```python
(3, 'Хороший, плохой, злой', 3, 1, 1, "For Three Men The Civil War Wasn't Hell. It Was Practice!")
(4, 'Последний киногерой', 3, 2, 2, "This isn't the movies anymore")
(5, 'Она написала убийство', 4, 3, 3, 'Tonight on Murder She Wrote') 
```

Результат тот же, а запрос выглядит лучше:

- соединение и фильтрация разделены; это упрощает понимание запроса;
- условия соединения таблиц содержатся в блоке `ON`, это уменьшает вероятность ошибки.

В классическом SQL существует пять типов `JOIN`; SQLite поддерживает только три из них. Но с помощью ловкости и смекалки неподдерживаемые типы можно заменить другими запросами.

### Внутреннее пресечение: INNER JOIN

На первый тип `JOIN` вы уже полюбовались: в примере выше был как раз `INNER JOIN` (или просто `JOIN`, без титулов).

Объединение таблиц через `INNER JOIN` можно представить схематически:

![](https://pictures.s3.yandex.net/resources/S02_193_1685550377.png)

Запрос через `JOIN` можно сделать и к трём таблицам. Присоединим таблицу **product_types**:

```sql
SELECT video_products.title,
       slogans.slogan_text,
       product_types.title
FROM video_products
JOIN slogans ON video_products.slogan_id = slogans.id
JOIN product_types ON video_products.type_id = product_types.id; 
```

Теперь `JOIN` обработал сразу три таблицы!

```python
('Хороший, плохой, злой', "For Three Men The Civil War Wasn't Hell. It Was Practice!", 'Фильм')
('Последний киногерой', "This isn't the movies anymore", 'Фильм')
('Она написала убийство', 'Tonight on Murder She Wrote', 'Сериал') 
```

![](https://pictures.s3.yandex.net/resources/S02_237_1678066461.png)

В этой выборке всего три фильма: мультики в неё не попали, ведь у них не указана связь с таблицей **slogans**.

> Оператор `INNER JOIN` включает в результирующую таблицу только те записи, в которых выполняется условие, заданное в `ON`.

### Левое внешнее соединение: LEFT OUTER JOIN

При обработке запроса `LEFT OUTER JOIN` объединяемые таблицы условно называют **«левая»** и **«правая»**. «Левая» — та, которая вызвана в блоке `FROM`, «правая» — та, что указана после ключевого слова `JOIN`. «Правых» таблиц может быть и несколько.

В этом запросе `OUTER` — не обязательное слово. Можно использовать сокращённую запись: `LEFT JOIN`.

При выполнении запросов с `LEFT JOIN` возвращаются **все строки левой таблицы**. Данными из **правой таблицы** дополняются только те строки левой таблицы, для которых выполняются условия соединения, описанные после оператора `ON`. Для недостающих данных вместо строк правой таблицы вставляется `NULL`.

```sql
SELECT video_products.title,
       slogans.slogan_text
FROM video_products
LEFT JOIN slogans ON video_products.slogan_id = slogans.id; 
```

Результат запроса:

```python
('Безумные мелодии Луни Тюнз', None)
('Весёлые мелодии', None)
('Хороший, плохой, злой', "For Three Men The Civil War Wasn't Hell. It Was Practice!")
('Последний киногерой', "This isn't the movies anymore")
('Она написала убийство', 'Tonight on Murder She Wrote') 
```

![](https://pictures.s3.yandex.net/resources/S02_238_1678066511.png)

«Безумные мелодии Луни Тюнз» и «Весёлые мелодии» остались в выборке, поскольку `LEFT JOIN` **возвращает все записи левой таблицы без исключения**. Но у этих фильмов нет слогана, и вместо слогана вернулся `NULL` (`None` в переводе на язык Python).

Графически связь `LEFT JOIN` изображается так:

![](https://pictures.s3.yandex.net/resources/S02_194_1685550398.png)

### RIGHT OUTER JOIN

`RIGHT JOIN` — это такое же объединение, как и `LEFT JOIN`, но **выводятся все записи из правой таблицы**, а к ним добавляются только те данные из левой таблицы, в которых есть ключ объединения.

Напишем запрос через `RIGHT JOIN`:

```sql
SELECT video_products.title,
       product_types.title
FROM video_products
RIGHT JOIN product_types ON video_products.type_id = product_types.id; 
```

Результат запроса будет таким:

```python
('Безумные мелодии Луни Тюнз', 'Мультсериал')
('Весёлые мелодии', 'Мультсериал')
('Последний киногерой', 'Фильм')
('Хороший, плохой, злой', 'Фильм')
('Она написала убийство', 'Сериал')
(None, 'Мультфильм') 
```

![](https://pictures.s3.yandex.net/resources/Untitled_1685290733.png)

Будут выведены все записи из правой таблицы (из **product_types**) и связанные с ними записи из левой (из **video_products**). В таблице **video_products** нет ни одной записи, ссылающейся на тип «Мультфильм», поэтому вместо значения `video_products.title` в этой строке стоит `None`.

SQLite поддерживает `RIGHT JOIN` [с 25 июня 2022 года](https://www.sqlite.org/releaselog/3_39_0.html) (версия 3.39.0). В более ранних версиях при попытке выполнить `RIGHT JOIN` возникнет ошибка:

```bash
sqlite3.OperationalError: RIGHT and FULL OUTER JOINs are not currently supported 
```

Выход есть: можно применить «разрешённый» в SQLite `LEFT JOIN`, поменяв таблицы местами. В нашем случае нужно назвать **product_types** главной (левой), а **video_products** присоединить через `LEFT JOIN`.

```sql
SELECT video_products.title,
       product_types.title
FROM product_types
LEFT JOIN video_products ON video_products.type_id = product_types.id; 
```

Результат этого запроса будет тем же, что и в предыдущем примере:

```python
('Безумные мелодии Луни Тюнз', 'Мультсериал')
('Весёлые мелодии', 'Мультсериал')
('Последний киногерой', 'Фильм')
('Хороший, плохой, злой', 'Фильм')
('Она написала убийство', 'Сериал')
(None, 'Мультфильм') 
```

Внезапное откровение

Графическое отображение `RIGHT JOIN`:

![](https://pictures.s3.yandex.net/resources/S02_195_1685550424.png)

### FULL OUTER JOIN

При запросе **FULL (OUTER) JOIN** выводятся **все записи из объединяемых таблиц**. Те записи, у которых запрошенные значения совпадают, — выводятся парами, у остальных недостающее значение заменяется на `NULL` (Python выведет `None`).

Другими словами, **FULL JOIN == LEFT JOIN + RIGHT JOIN.**

В классическом SQL сработает такой запрос:

```sql
SELECT video_products.title,
       slogans.slogan_text
FROM video_products
FULL JOIN slogans ON video_products.slogan_id = slogans.id; 
```

Результат запроса:

```python
(None, "I'll be back")
('Безумные мелодии Луни Тюнз', None)
('Весёлые мелодии', None)
('Она написала убийство', 'Tonight on Murder She Wrote')
('Последний киногерой', "This isn't the movies anymore")
('Хороший, плохой, злой', "For Three Men The Civil War Wasn't Hell. It Was Practice!") 
```

![](https://pictures.s3.yandex.net/resources/S02_240_1678066741.png)

SQLite поддерживает **FULL JOIN** с 25 июня 2022 года (версия 3.39.0). В более старых версиях при попытке выполнить такой запрос вернётся ошибка:

```bash
sqlite3.OperationalError: RIGHT and FULL OUTER JOINs are not currently supported 
```

При возникновении такой ошибки можно пойти другим путём: выполнить два запроса `LEFT JOIN` и выполнить команду `UNION` — она объединяет данные из нескольких результирующих таблиц в одну:

```sql
SELECT video_products.title,
       slogans.slogan_text
FROM video_products
LEFT JOIN slogans ON video_products.slogan_id = slogans.id
UNION
SELECT video_products.title,
       slogans.slogan_text
FROM slogans
LEFT JOIN video_products ON video_products.slogan_id = slogans.id; 
```

Графически `FULL JOIN` можно представить так:

![](https://pictures.s3.yandex.net/resources/S02_196_1685550436.png)

### CROSS JOIN

Объединение таблиц через `CROSS JOIN` возвращает декартово произведение таблиц — каждая запись левой таблицы объединится с каждой записью правой. Параметр `ON` при запросах `CROSS JOIN` не применяется.

```sql
SELECT video_products.title,
       slogans.slogan_text
FROM video_products
CROSS JOIN slogans; 
```

Распечатаем результаты запроса:

```python
('Безумные мелодии Луни Тюнз', "For Three Men The Civil War Wasn't Hell. It Was Practice!")
('Безумные мелодии Луни Тюнз', "This isn't the movies anymore")
('Безумные мелодии Луни Тюнз', 'Tonight on Murder She Wrote')
('Безумные мелодии Луни Тюнз', "I'll be back")
('Весёлые мелодии', "For Three Men The Civil War Wasn't Hell. It Was Practice!")
('Весёлые мелодии', "This isn't the movies anymore")
('Весёлые мелодии', 'Tonight on Murder She Wrote')
('Весёлые мелодии', "I'll be back")
('Хороший, плохой, злой', "For Three Men The Civil War Wasn't Hell. It Was Practice!")
('Хороший, плохой, злой', "This isn't the movies anymore")
('Хороший, плохой, злой', 'Tonight on Murder She Wrote')
('Хороший, плохой, злой', "I'll be back")
('Последний киногерой', "For Three Men The Civil War Wasn't Hell. It Was Practice!")
('Последний киногерой', "This isn't the movies anymore")
('Последний киногерой', 'Tonight on Murder She Wrote')
('Последний киногерой', "I'll be back")
('Она написала убийство', "For Three Men The Civil War Wasn't Hell. It Was Practice!")
('Она написала убийство', "This isn't the movies anymore")
('Она написала убийство', 'Tonight on Murder She Wrote')
('Она написала убийство', "I'll be back") 
```

На практике `CROSS JOIN` применяется не очень часто, но и он может быть полезен. Например, если в одной таблице сохранён список жидкостей, а во второй — список возможной тары для расфасовки, от маленькой баночки до цистерны. В выборке получим все возможные комбинации «жидкость — тара».