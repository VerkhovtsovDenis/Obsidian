# Отношения между таблицами. «Многие ко многим»

У каждой картины есть автор. Но если в живописи два автора одной картины — это редкость, то несколько режиссёров одного фильма — это обычное дело. Публика хочет знать имена режиссёров, так что добавим их в нашу базу данных.

Для начала опишем условия:

- У фильма может быть один или несколько режиссёров.
- Режиссёр может снять один или несколько фильмов.

Это классический пример связи N:M, «многие ко многим».

Соберём имена режиссёров в отдельную таблицу:

![](https://pictures.s3.yandex.net/resources/S2_141_1_1682533873.png)

Немного расширим список фильмов и сопоставим их названия с `id` режиссёров:

![](https://pictures.s3.yandex.net/resources/S2_160_1682533887.png)

![](https://pictures.s3.yandex.net/resources/S02_227_1685551410.png)

Для сериала «Она написала убийство» в нашей базе указано целых три режиссёра, и чтобы указать их — в поле `director_id` пришлось бы перечислить несколько id. Однако в одной ячейке типа INTEGER должно храниться только одно число.

На практике такую связь организуют через промежуточную таблицу: в ней сопоставляют идентификаторы записей из связываемых таблиц.

![](https://pictures.s3.yandex.net/resources/S02_232_1_1685551419.png)

Промежуточная таблица названа по именам таблиц, которые через неё связаны: **directors__video_products**.

Она содержит

- поле `director_id` типа `FOREIGN KEY`, ссылающееся на колонку `id` в таблице **directors**;
- поле `video_product_id` типа `FOREIGN KEY`, ссылающееся на колонку `id` в таблице **video_products**.

В итоге каждая запись промежуточной таблицы ссылается на записи в таблицах **directors** и **video_products**. Связь построена!

![](https://pictures.s3.yandex.net/resources/S2_161_1682533906.png)

Любой режиссёр может снять один фильм только один раз. Значит, каждая пара «фильм — режиссёр» уникальна в пределах таблицы. А уникальные значения могут служить первичными ключами записей.

Поэтому здесь в качестве `PRIMARY KEY` используется сочетание `(director_id, video_product_id)` — эта пара уникальна в пределах таблицы. Сочетание значений этих полей служит **композитным** первичным ключом.

Создать таблицу с композитным первичным ключом можно так:

```sql
CREATE TABLE IF NOT EXISTS video_products(
    id INTEGER PRIMARY KEY,
    title TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS directors(
    id INTEGER PRIMARY KEY,
    full_name TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS directors__video_products(    
    director_id INTEGER NOT NULL,
    video_product_id INTEGER NOT NULL,
    -- Пару полей назначаем композитным первичным ключом:
    PRIMARY KEY (director_id, video_product_id),
    FOREIGN KEY(director_id) REFERENCES directors(id),
    FOREIGN KEY(video_product_id) REFERENCES video_products(id)
); 
```

Вольный перевод SQL-запроса на русский язык:

- создаём таблицы **video_products** и **directors** и промежуточную таблицу **directors__video_products**;
- в промежуточной таблице указываем связь между записями двух таблиц;
- в таблице **directors__video_products** создаём композитный первичный ключ из полей `director_id` и `video_product_id`; при этом решается и вторая задача: теперь каждая пара полей будет уникальна в пределах таблицы, и никто не сможет повторно связать фильм с режиссёром.

Теперь любую запись из таблицы **directors** можно связать с несколькими фильмами из **video_products**, а фильм можно связать с несколькими режиссёрами.

---
#### Задание

К мороженому может прилагаться _топпинг_ — какая-то добавка, которая делает мороженое ещё вкуснее (даже если вкуснее некуда).

Есть множество топпингов, их названия хранятся в таблице `toppings`.

Свяжите таблицы `ice_cream` и `toppings` через промежуточную таблицу `ice_cream_toppings` так, чтобы у мороженого могло быть несколько топпингов, а могло бы не быть вовсе. У разных сортов мороженого могут быть одинаковые топпинги.

В промежуточной таблице обязательно создайте колонку с первичным ключом.

Ключ в промежуточной таблице, связывающей `ice_cream` и `toppings`, **не должен быть композитным**. Связь мороженного и топпинга — это неуникальная комбинация: к одному мороженому можно привязать не один, а два, пять или десять **одинаковых** топпингов.

Поэтому в таблице обязательно нужна колонка `id PRIMARY KEY`.

При выполнения задания не изменяйте прекод.

#### Подсказка

Создайте промежуточную таблицу `ice_cream_toppings` с полями

- `id`: первичный ключ, `INTEGER`;
- `ice_cream_id`: обязательное поле, `INTEGER`;
- `topping_id`: обязательное поле, `INTEGER`;

Поля `ice_cream_id` и `topping_id` должны быть внешними ключами и ссылаться «один ко многим» на таблицы `ice_cream` и `toppings`.

#### Решение
```python
import sqlite3
 
con = sqlite3.connect('db.sqlite')
cur = con.cursor()
  
cur.executescript('''
CREATE TABLE IF NOT EXISTS toppings(
    id INTEGER PRIMARY KEY,
    title TEXT NOT NULL
);
  
CREATE TABLE IF NOT EXISTS ice_cream(
    id INTEGER PRIMARY KEY,
    title TEXT NOT NULL
);
  
CREATE TABLE IF NOT EXISTS ice_cream_toppings(
    id INTEGER PRIMARY KEY,
    ice_cream_id INTEGER NOT NULL,
    topping_id INTEGER NOT NULL,
    FOREIGN KEY(ice_cream_id) REFERENCES ice_cream(id),
    FOREIGN KEY(topping_id) REFERENCES toppings(id)
);
''')
  
con.close()
```