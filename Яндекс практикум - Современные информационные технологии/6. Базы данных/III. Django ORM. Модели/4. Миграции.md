После того как модели созданы, на их основе нужно создать таблицы в БД. Django ORM делает это с помощью механизма **миграций**. Миграции выполняются в два этапа:

1. Разработчик запускает команду `python manage.py makemigrations`. По этой команде Django ORM прочтёт и проанализирует все модели проекта, проверит, не приведут ли предполагаемые изменения к проблемам. Если всё хорошо — список планируемых изменений будет сохранён в папке _migrations/_ приложений в отдельных файлах. Если в какой-то момент модели снова будут изменены и снова потребуются миграции — при следующем выполнении команды `makemigrations` будет создан новый файл миграций; таким образом информация о миграциях сохраняется и накапливается. Это даёт возможность, например, «откатиться» к какому-то из предыдущих состояний БД. При выполнении команды `makemigrations` никаких изменений в БД не вносится.
2. После того как миграции созданы, разработчик запускает команду `python manage.py migrate`; основываясь на файлах миграций, Django создаст и выполнит SQL-запросы, формирующие или изменяющие таблицы.

> Файлы миграции каждого приложения следует добавлять в git: миграции — это неотъемлемая часть проекта.

## Миграции Анфисы

Посмотрим, как работают миграции на практике.

- Клонируйте [репозиторий с проектом «Анфиса для Друзей»](https://github.com/yandex-praktikum/anfisa2sprint). В нём уже созданы все необходимые модели.
- Создайте виртуальное окружение проекта.
- Активируйте виртуальное окружение проекта, обновите pip.
- В активированном виртуальном окружении установите зависимости из _requirements.txt._

Осмотрите проект: прочтите модели, разберитесь, что к чему — и поехали выполнять миграции!

### Этап 1. Создаём файлы миграций: makemigrations

Перейдите в директорию с файлом _manage.py_ (виртуальное окружение должно быть активно) и выполните команду

``` bash
python manage.py makemigrations 
```

Запустится процесс проверки моделей, после этого будет создан файл миграций.

В консоли появится сообщение, что в директории _ice_cream/migrations/_ создан файл _0001_initial.py_, а в нём записаны операции, которые Django ORM планирует выполнить:

![](https://pictures.s3.yandex.net/resources/1_1685546736.png)

Имя файла обязательно содержит номер миграции и дополнительную информацию о миграции. Например, _initial_ — это первая миграция в приложении. При следующих миграциях названия файлов будут иными, а последовательные номера будут присваиваться автоматически. В каждом приложении проекта создаются собственные файлы миграций и ведётся независимая нумерация.

После создания файла миграций обязательно загляните в него. Cопоставьте содержимое файла с моделями проекта, и станет видно, как устроен этот файл.

Файл миграций _—_ это инструкция для составления SQL-запроса. Увидеть запрос, который будет создан, можно с помощью команды

```bash
 python manage.py sqlmigrate ice_cream 0001  
```

где `ice_cream` — имя приложения, а `0001` — это номер миграции.

Запрос, составленный на основе файла 0001_initial.py, будет таким:

В SQL-запросе есть несколько незнакомых команд; вы можете выяснить их назначение самостоятельно.

Таким же образом можно посмотреть запросы любой другой миграции из любого приложения.

Файл миграции — это не магия вне Хогвартса, а просто инструкция для формирования SQL-запроса.

### Этап 2. Применяем миграции: migrate

Подготовка окончена, выполняем миграции: при активированном виртуальном окружении из директории с файлом _manage.py_ выполните команду

```bash
python manage.py migrate 
```

И тут начнётся:

![](https://pictures.s3.yandex.net/resources/2_1_1685546754.png)

Отметка `OK` означает, что очередная операция успешно завершена.

Будет создано и несколько таблиц для встроенных приложений Django: _auth_, _admin_, _sessions_, _contenttypes_.

Начальные миграции для этих таблиц встроены в соответствующие приложения, и Django оставалось только применить их.

Проект **Анфиса для друзей** готов к работе с данными! Создана база данных SQLite, а в ней — таблицы для приложения **ice_cream** и таблицы служебных приложений.

## Окно в базу данных

После выполнения миграций будет интересно заглянуть в базу данных (файл db.sqlite3) и посмотреть, что там новенького.

![](https://pictures.s3.yandex.net/resources/3_1_1685546769.png)

База данных не должна попасть в git, поэтому нужно добавить в _.gitignore_ правило, исключающее файлы _.sqlite_ и _.sqlite3_ из репозитория: файлы БД SQLite могут быть с разным расширением.

Следующий этап — научиться управлять информацией в БД через модели. Но сперва — квиз.

Классическая задача: развернуть Django-проект, который выложен на GitHub. Все команды известны, но кто-то сложил их в мешок, перемешал и вытряхнул — теперь они в полном беспорядке.

Расставьте команды в порядке применения при развёртывании Django-проекта.

1.

`git clone`

Верно!

2.

`python -m venv venv`

Верно!

3.

`source venv/bin/activate` или `source venv/Scripts/activate`

Верно!

4.

`pip install -r requirements.txt`

Верно!

5.

`python manage.py migrate`

Верно!

Начать заново

Сохраните эту последовательность команд, она не раз вам пригодится. Если сделать скриншот, распечатать его на картоне и прибить гвоздиком к монитору — он точно не потеряется!

В списке команд нет `makemigrations`, и это не просто так. По правилам хорошего тона в репозитории проекта должны храниться и миграции проекта. В такой ситуации при развёртывании проекта выполнять команду `makemigrations` не нужно: требуется просто применить миграции, сохранённые в репозитории.

### Шпаргалка

Полезные команды при миграциях:

- `python manage.py migrate` применение миграции.
- `python manage.py makemigrations` создание новых миграций на основе изменений, внесённых в модели.
- `python manage.py sqlmigrate <имя приложения> <номер миграции>` отображает SQL-запросы, которые будут отправлены при миграции.
