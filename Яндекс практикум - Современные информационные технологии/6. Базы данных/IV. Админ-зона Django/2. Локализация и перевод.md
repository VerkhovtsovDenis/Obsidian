Вам предстоит перевести интерфейс админки на русский язык. Админку надо настроить так, чтобы админу было удобно. Изменение языковых настроек называют «интернационализация». Есть ещё «локализация» — адаптация интерфейса к традициям и особенностям языка, страны или региона.

Например, мы записываем дату в формате день-месяц-год, а в Америке — месяц-день-год. И без локализации сложно разобраться, какая это дата — 10.11.12. В общем, локализация под русский язык нам тоже нужна.

Конкретизируем задачу. Вот что нужно сдедать:

1. Перевести и локализовать интерфейс админки.
2. Перевести название проекта: вместо _ice_cream_ должно быть «Каталог мороженого».
3. Перевести названия моделей в админке:
    - Category — «Категории»
    - Topping — «Топпинги»
    - Wrapper — «Обёртки»
    - IceCream — «Мороженое»
4. Перевести названия столбцов таблиц.
5. Настроить отображение записей так, чтобы вместо `IceCream object (<id>)` отображалось название сорта мороженого (значение поля `title` записи).

## Локализация и перевод

В Django есть встроенная система интернационализации, она поддерживает множество языков.

Чтобы переключить интерфейс админки на другой язык, надо [найти кодовое обозначение нужного языка](http://www.i18nguy.com/unicode/language-identifiers.html) и подставить его в константу `LANGUAGE_CODE` в файле _settings.py_:

```python
# anfisa_for_friends/settings.py

# Переводим на русский!
LANGUAGE_CODE = 'ru-RU' 
```

При изменении значения константы `LANGUAGE_CODE` на `'ru-RU'` все тексты встроенных веб-интерфейсов Django будут отображаться по-русски; помимо этого, проект будет и локализован: даты будут отображаться в привычном нам формате.

![](https://pictures.s3.yandex.net/resources/S3.2_22_1679041628.png)

Никакой магии при переводе интерфейса не происходит. Все тексты, отображающиеся в админке и на других стандартных страницах Django, хранятся в отдельных файлах. Когда в _settings.py_ разработчик меняет код языка — к проекту подключается файл с текстами на выбранном языке.

Можно заглянуть в эти файлы, они хранятся в директории виртуального окружения проекта _/venv_. Адреса могут быть чуть разными, в зависимости от системы и настроек компьютера:

- **Windows**: _venv\Lib\site-packages\django\contrib\admin\locale\ru\LC_MESSAGES_
- **Linux/macOS**: _venv/lib/python<версия питона>/site-packages/django/contrib/admin/locale/ru/LC_MESSAGES/_

**Переключите интерфейс проекта «Анфиса для друзей» на русский язык** и посмотрите, как изменится админка и другие страницы — например, страница авторизации.

## Verbose name: переводим названия приложения и моделей

Название приложений придуманы разработчиком, и перевести эти названия должен сам разработчик: в файле интернационализации таких переводов точно нет.

Задать название приложения в том виде, как оно должно отображаться в интерфейсах Django, можно в файле _apps.py._

Добавьте в класс `IceCreamConfig` свойство `verbose_name` со значением `'Каталог мороженого'`; сохраните файл, обновите страницу админ-зоны: название раздела в админке изменится.

```python
# ice_cream/apps.py
from django.apps import AppConfig

class IceCreamConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ice_cream'
    # Добавить строчку:
    verbose_name = 'Каталог мороженого' 
```

Выражение `verbose_name` в примерном переводе означает «расширенное название».

## Переводим название модели

Управление записями БД в админке разбито на разделы в соответствии с моделями; разделы названы по названиям моделей.

Но администратор сайта, скорее всего, понятия не имеет о моделях: для него слова _Categorys_, _Ice creams_, _Topping_ и _Wrapper_ — просто заголовки на странице. И он удивится: «почему было не назвать разделы понятно?». Не проблема, поможем админу.

Название модели, которое будет отображаться в админке, нужно указать в классе `Meta` этой модели.

Понадобится добавить два свойства:

- `verbose_name` — расширенное название_,_
- `verbose_name_plural` — расширенное название во множественном числе_._

```python
# ice_cream/models.py
...

class Category(PublishedModel):
    title = models.CharField(max_length=256)
    slug = models.SlugField(max_length=64, unique=True)
    output_order = models.PositiveSmallIntegerField(default=100)

    class Meta:
        verbose_name = 'категория'
        verbose_name_plural = 'Категории' 
```

**Добавьте** эти свойства в код и посмотрите, как изменится отображение админки:

![](https://pictures.s3.yandex.net/resources/S3.2_25_1679041724.png)

**Зарегистрируйте в админке и добавьте в проект переводы** для всех остальных моделей:

- Category — «Категории» (готово)
- Topping — «Топпинги»
- Wrapper — «Обёртки»
- IceCream — «Мороженое»

## Переводим названия атрибутов моделей

Названия атрибутов моделей отображаются, например, на страницах создания или редактирования объекта в админ-зоне.

![](https://pictures.s3.yandex.net/resources/S3.2_26_1679041744.png)

В админ-зоне заголовки полей ввода генерируются из названий атрибутов модели и выглядят они непонятно; лучше дать этим полям нормальные читаемые заголовки. В Django предусмотрена такая возможность: для каждого из атрибутов модели можно указать аргумент `verbose_name`:

```python
# ice_cream/models.py
...

class Category(PublishedModel):
    title = models.CharField(max_length=256, verbose_name='Название')
    slug = models.SlugField(max_length=64, unique=True, verbose_name='Слаг')
    output_order = models.PositiveSmallIntegerField(
        default=100,
        verbose_name='Порядок отображения'
    )  
```

Человекочитаемое название поля можно указать первым позиционным аргументом:

```python
# ice_cream/models.py
...

class Category(PublishedModel):
    title = models.CharField('Название', max_length=256)
    slug = models.SlugField('Слаг', max_length=64, unique=True)
    output_order = models.PositiveSmallIntegerField(
        'Порядок отображения',
        default=100
    ) 
```

Эти варианты взаимозаменяемы, однако последний вариант не всегда применим. Например, при указании типа поля ForeignKey первым параметром указывается связанная модель.

**Опишите** `verbose_name` для всех полей моделей:

- Category is_published — «Опубликовано» title — «Название» slug — «Слаг» output_order — «Порядок отображения»
- Тopping is_published — «Опубликовано» title — «Название» slug — «Слаг»
- IceCream is_published — «Опубликовано» is_on_main — «На главную» title — «Название» description — «Описание»
- Wrapper is_published — «Опубликовано» title — «Название»

При наследовании от абстрактных моделей `verbose_name` поля надо указывать в абстрактной модели. В проекте **anfisa_for_friends** поле `is_published` вынесено в абстрактную модель `PublishedModel`, так что переводить его нужно в описании этой модели.

В связанных моделях также можно использовать `verbose_name`. Посмотрите, что будет, если сделать:

```python
# ice_cream/models.py

...

class IceCream(PublishedModel):
    ...
    category = models.ForeignKey(
        Category,
        on_delete=models.CASCADE,
        related_name='ice_creams',
        verbose_name='Категория'
    )
... 
```

## Выводим читаемые названия объектов

Список объектов любой из моделей выглядит в админке не очень презентабельно и совершенно непригоден для управления данными: как понять, что за сорт мороженого кроется, например, под заголовком _IceCream object (8)_?

Настроим вывод записей так, чтобы в качестве заголовка показывалось название мороженого (значение поля `title`). Те же настройки подойдут и для других моделей.

Для этого в модели нужно переопределить «магический» метод `__str__()` и указать в нём, какое поле должно возвращаться в качестве строкового представления объекта:

```python
# ice_cream/models.py
...

class Category(PublishedModel):
    title = models.CharField(max_length=256, verbose_name='Название')
    slug = models.SlugField(max_length=64, unique=True, verbose_name='Слаг')
    output_order = models.PositiveSmallIntegerField(
        default=100,
        verbose_name='Порядок отображения'
    )

    class Meta:
        verbose_name = 'категория'
        verbose_name_plural = 'Категории'

    def __str__(self):
        return self.title 
```

По [правилам оформления кода Django](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#model-style) метода `__str__()` полагается определять после класса `Meta`.

Переопределите метод `__str__()` во всех моделях проекта — и работать с админкой станет гораздо проще:

![](https://pictures.s3.yandex.net/resources/S3.2_27_1679042872.png)

Готово. Админ-зона стала удобной и понятной; администратор сайта разберётся в ней без проблем и даже не узнает, как печально выглядела админка до вашего вмешательства.

Таков путь: бэкендеры — герои, скрывающиеся в тени, про них никто не знает, пока всё работает хорошо. Вот как сейчас.

### На заметку

- После добавления/изменения verbose_name и атрибутов класса Meta стоит создать и применить миграции. Несмотря на то, что Django создаёт в этом случае новые миграции, физически структура БД не меняется.
- В работе соблюдайте код-стайл описания моделей Django. Познакомиться с ним поближе можно [здесь](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#model-style).

---

### Задания
#### Задание 1/1

##### Описание задания
Повторите практические задания урока в тренажёре: локализуйте и переведите админ-зону; настройте отображение элементов.

Вот что нужно сделать:

1. Перевести интерфейс админки на русский язык.
2. Перевести название приложения ICE_CREAM: в админ-зоне должно отображаться название _Каталог мороженого_.
3. Перевести названия моделей:
    - Category — «Категории»
    - Topping — «Топпинги»
    - Wrapper — «Обёртки»
    - IceCream — «Мороженое»
4. Перевести названия полей в админке:
    - Category is_published — «Опубликовано» title — «Название» slug — «Слаг» output_order — «Порядок отображения»
    - Topping is_published — «Опубликовано» title — «Название» slug — «Слаг»
    - IceCream is_published — «Опубликовано» is_on_main — «На главную» title — «Название» description — «Описание»
    - Wrapper is_published — «Опубликовано» title — «Название»
5. Настроить отображение объектов так, чтобы в списке объектов вместо _IceCream object (1)_ отображалось название мороженого (значение поля `title`). Таким же образом надо настроить и остальные модели приложения **ice_cream**.

##### Подсказка
Импортируйте нужные модели из _models.py_.

Посмотрите в теории урока, как зарегистрирована модель `Category`, и проделайте то же самое с другими моделями.

##### Решение задания
```python
# core/models.py
from django.db import models
  
class PublishedModel(models.Model):
    """Абстрактная модель. Добвляет флаг is_published."""
    is_published = models.BooleanField(default=True, verbose_name="Опубликовано")
  
    class Meta:
        abstract = True
    def __str__(self):
        return self.title
```

```python
# ice_cream/models.py
from django.db import models

from core.models import PublishedModel


class Category(PublishedModel):
    title = models.CharField(max_length=256, verbose_name="Название")
    slug = models.SlugField(max_length=64, unique=True, verbose_name="Слаг")
    output_order = models.PositiveSmallIntegerField(default=100, verbose_name="Порядок отображения")
    class Meta:
        verbose_name = "Категория"
        verbose_name_plural = "Категории"


class Topping(PublishedModel):
    title = models.CharField(max_length=256, verbose_name="Название")
    slug = models.SlugField(max_length=64, unique=True, verbose_name="Слаг")
    class Meta:
        verbose_name = "Топпинг"
        verbose_name_plural = "Топпинги"


class Wrapper(PublishedModel):
    title = models.CharField(max_length=256, verbose_name="Название")
    class Meta:
        verbose_name = "Обёртка"
        verbose_name_plural = "Обёртки"


class IceCream(PublishedModel):
    is_on_main = models.BooleanField(default=False, verbose_name="На главную")
    title = models.CharField(max_length=256, verbose_name="Название")
    description = models.TextField(verbose_name="Описание")
    wrapper = models.OneToOneField(
        Wrapper,
        on_delete=models.SET_NULL,
        related_name='ice_cream',
        null=True,
        blank=True,
        verbose_name='Обёртка'
    )
    category = models.ForeignKey(
        Category,
        on_delete=models.CASCADE,
        related_name='ice_creams',
        verbose_name='Категория'
    )
    toppings = models.ManyToManyField(Topping, verbose_name='Топпинги')

    class Meta:
        verbose_name = "Мороженое"
        verbose_name_plural = "Мороженое"
```

```python
# anfise_for_frends/settings.py
...
LANGUAGE_CODE = 'ru-RU'
...
```
Лучше написать код, чем прочитать о том, как его пишут. А два раза написать код — ещё лучше. Повторение — мать!