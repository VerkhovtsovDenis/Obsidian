Сейчас веб-страницы и база данных находятся отдельно: информация из БД видна только в админке. Наша задача — показать эту информацию пользователю.

У нас есть view-функция для главной страницы. В этой функции мы:

- сделаем запрос к модели `IceCream` через ORM: `IceCream.objects.all()`, «получить все объекты модели»;
- получим QuerySet со всеми объектами этой модели;
- передадим этот QuerySet в словарь `context` под каким-нибудь ключом, например, `ice_cream_list`;
- в шаблоне выведем переменную `ice_cream_list`, мы так уже делали.

А теперь о конкретных задачах. Надо подготовить запросы к БД для трёх страниц проекта «Анфиса для друзей»:

- на главную вывести избранные записи из БД,
- на страницу _/ice_cream/_ вывести все объекты `IceCream`, какие есть в базе,
- на страницу _/ice_cream/`<pk>`/_ вывести полную информацию о запрошенном сорте мороженого.

Когда фронтендеры определятся с дизайном главной страницы, подключим шаблоны к проекту. Пока вы напишете простенький HTML-шаблон, в него выведете данные. А когда подъедет вёрстка, замените HTML-код в шаблоне — и готово.

## Полный список мороженого на главной странице

Обработкой запросов к главной странице занимается view-функция `index()` приложения **homepage**. Вот в ней-то и сделаем запрос к БД: «получить все поля всех объектов модели `IceCream`».

На SQL этот запрос выглядел бы так:

```sql
SELECT *
FROM <имя таблицы>; 
```

Но у нас есть Django ORM, так что запрос делаем не на SQL, а на Python:

```python
# homepage/views.py
from django.shortcuts import render

from ice_cream.models import IceCream

def index(request):
    template_name = 'homepage/index.html'
    # Запрос:
    ice_cream_list = IceCream.objects.all()
    # Полученный из БД QuerySet передаём в словарь контекста:
    context = {
        'ice_cream_list': ice_cream_list,
    }
    # Словарь контекста передаём в шаблон, рендерим HTML-страницу:
    return render(request, template_name, context) 
```

Посмотрим, какой запрос отправлен для формирования главной страницы. Для чистоты эксперимента надо выйти из аккаунта администратора сайта.

Открываем главную страницу и смотрим запрос через Django Debug Toolbar:

![](https://pictures.s3.yandex.net/resources/S3.2_35_1679044831.png)

Запросов нет. Это нормально. До тех пор, пока информация из БД не запрошена в шаблоне или каким-то ещё образом, — запросы не отправляются.

А сейчас в шаблоне _index.html_ никакие данные из словаря `context` не выводятся. В такой ситуации Django рассуждает так: «зачем делать запрос, если информация никому не нужна?». Это называется «ленивые запросы»: не пнёшь — не полетят.

Запрос будет отправлен, если в шаблоне будут запрошены данные из словаря `context`; добавим в HTML-шаблон переменную из этого словаря:

```html
 <!-- templates/homepage/index.html -->
...

<h1 class="pb-2 mb-0">Главная страница</h1>
{{ ice_cream_list }}

... 
```

И теперь, когда информация из БД востребована в шаблоне, при запросе к главной странице будет отправлен SQL-запрос:

![](https://pictures.s3.yandex.net/resources/S3.2_36_1679044940.png)

А веб-страница будет выглядеть так:

![](https://pictures.s3.yandex.net/resources/S3.2_37_1679044950.png)

На страницу выведен QuerySet со списком объектов из запроса.

Прямо в шаблоне можно проитерироваться по QuerySet, получить свойства каждого объекта и вывести их на страницу, например, в виде HTML-списка:

```django
<!-- templates/homepage/index.html -->
...

{% for ice_cream in ice_cream_list %}
  <ul>
    <li>ID: {{ ice_cream.id }}</li>
    <li>Опубликовано: {{ ice_cream.is_published }}</li>
    <li>На главную: {{ ice_cream.is_on_main }}</li>
    <li>Название: {{ ice_cream.title }}</li>
    <li>Описание: {{ ice_cream.description }}</li>
    <li>FK wrapper: {{ ice_cream.wrapper_id }}</li>
    <li>FK category: {{ ice_cream.category_id }}</li>
  </ul>
{% endfor %} 
```

При рендеринге шаблона будет создан такой HTML-код:

```django
  <ul>
    <li>ID: 1</li>
    <li>Опубликовано: True</li>
    <li>На главную: True</li>
    <li>Название: Золотое мороженое</li>
    <li>Описание: Шарики таитянского ванильного мороженого, шоколад “Amedei Porcelana” и груда экзотических фруктов. Всё это покрыто золотой фольгой, её тоже полагается съесть.</li>
    <li>FK wrapper: None</li>
    <li>FK category: 1</li>
  </ul>
  <ul>
    <li>ID: 2</li>
    <li>Опубликовано: True</li>
    <li>На главную: False</li>
    <li>Название: Готическое мороженое</li>
    <li>Описание: Чёрное мороженое в чёрном вафельном рожке для true black goths. Состав: сливочное мороженое, миндаль, активированный уголь, чернота, мрак, отрицание.</li>
    <li>FK wrapper: None</li>
    <li>FK category: 1</li>
  </ul>
... 
```

…и так все сорта мороженого из БД.

![](https://pictures.s3.yandex.net/resources/S3.2_38_1679045014.png)

Кажется, это был ещё один шаг к победе.

### Метод values(): берём только нужное

В QuerySet содержатся все поля объектов модели `IceCream`, но на странице, которая отправляется пользователю, совершенно не нужны поля `is_published`, `is_on_main`, `wrapper_id` и `category_id`: это техническая информация, не предназначенная для пользователя. Получается, мы напрасно запрашивали эти поля и передавали их в шаблон, создавая лишнюю нагрузку на сервер.

Ограничим количество столбцов, попадающих в выборку. В SQL следовало бы сделать так:

```sql
SELECT <столбец1>, <столбец2>
FROM <имя таблицы>; 
```

А в Django ORM поля, которые нужно получить из БД, перечисляются в аргументах метода `.values()`:
```python
<Название модели>.objects.values('<свойство1>', '<свойство2>') 
```

Обновите код view-функции:

```python
# homepage/views.py
from django.shortcuts import render

from ice_cream.models import IceCream

def index(request):
    template_name = 'homepage/index.html'
    # Возьмём нужное. А ненужное не возьмём:
    ice_cream_list = IceCream.objects.values('id', 'title')
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template_name, context) 
```

При таком запросе в QuerySet попадут значения только тех полей, которые перечислены в `values()`:

```python
<QuerySet [{'id': 1, 'title': 'Золотое мороженое'}, {'id': 2, 'title': 'Готическое мороженое'}, {'id': 3, 'title': 'Мороженое паста карбонара'}, ...]> 
```

При вызове метода `.values()` в QuerySet попадает не список объектов, а список **словарей**; ключами этого словаря служат названия свойств, а значениями — значения этих свойств.

Измените шаблон, чтобы наблюдать за результатами не только в Django Debug Toolbar, но и на странице проекта:

```django
<!-- templates/homepage/index.html -->
...

{% for ice_cream in ice_cream_list %}
  <ul>
    <li>ID: {{ ice_cream.id }}</li>
    <li>Название: {{ ice_cream.title }}</li>
  </ul>
{% endfor %} 
```

Передавать в запросе только те данные, которые используются на странице — правильный подход: чем меньше передаётся информации, тем быстрее всё работает.

![](https://pictures.s3.yandex.net/resources/S3.2_39_1679045040.png)

---

### Задания

#### Задание 1/1
##### Описание задания
В файле _homepage/views.py_ измените функцию `index()` так, чтобы на главную страницу проекта передавались только те данные, которые используются в шаблоне.

##### Подсказка
Используйте метод `.values()` из интерфейса `objects` модели. Обратите внимание, что названия свойств предаются в него в виде строк.

Какие данные нужно предать в шаблон — можно увидеть в файле _/templates/homepage/index.html_

##### Решение задания
```python
# homepage/views.py
from django.shortcuts import render

from ice_cream.models import IceCream


def index(request):
    template = 'homepage/index.html'
    # Запишите в переменную ice_cream_list новый QuerySet
    ice_cream_list = IceCream.objects.all().values('title', 'id', 'description')
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template, context)
```

Отличный результат. Чтобы не растерять успех — скопируйте своё решение в развёрнутый на вашем компьютере проект «Анфиса для друзей». Пригодится!