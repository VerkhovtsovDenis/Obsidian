

Первый этап работы выполнен: информация из БД передаётся на запрошенную страницу. «Логистика» отлажена, теперь нужно заняться деталями. Сейчас на главной странице отображаются все до единой записи из БД. Но мы не просто так придумали поле `is_on_main`: на главную должны выводиться лишь те сорта, у которых в этом поле стоит `True`.

Так как мы работаем через ORM, фильтрация по значениям полей выполняется методами `.filter(<условие>)` и `.exclude(<условие>)`. Вместо операторов сравнения в Django ORM применяются **модификаторы**.

Разберём на примере. Вот несложный запрос на SQL: получить те записи, у которых значение поля `id` — строго больше пяти.

```sql
SELECT *
FROM ice_cream_icecream
WHERE id > 5; 
```

В Django ORM этот запрос будет выглядеть так:

```python
IceCream.objects.filter(id__gt=5)
# <Модель>.objects.filter(<свойство>__<модификатор>=<значение>) 
```

Вместо `.all()` применяется метод `.filter()` с переданным в него аргументом для фильтрации.

Обратите внимание: при **любом** сравнении в выражении применяется символ `=`. Таков путь. За сравнение отвечает именно модификатор (в данном случае `__gt` — строго больше).

Модификаторов в Django ORM довольно много; с них и начнём знакомство с фильтрами.

### Модификаторы сравнения

В Django ORM модификаторы выполняют роль операторов, используемых в SQL для фильтрации выборки по значениям полей. Вот как переводятся самые востребованные модификаторы (перед модификатором обязательно ставится двойной символ подчёркивания):

|Значение оператора|SQL|ORM|
|---|---|---|
|Равно|=|__exact|
|Сравнение с NULL|IS NULL|__exact=None|
|Больше|>|__gt|
|Больше или равно|>=|__gte|
|Меньше|<|__lt|
|Меньше или равно|<=|__lte|
|Поиск по тексту|LIKE '%фраза%'|__contains='фраза'|
|Вхождение в множество|IN (1, 3, 4)|__in=[1, 3, 4]|
|Вхождение в диапазон|BETWEEN 1 AND 4|__range=[1, 4]|

Полный список модификаторов есть в [документации Django](https://docs.djangoproject.com/en/3.2/ref/models/querysets/#field-lookups).

А теперь посмотрим повнимательнее на методы фильтрации.

## Метод filter()

Метод `.filter()` **принимает** на вход именованные (keyword) аргументы:

- название поля,
- модификатор поиска,
- значение для фильтрации;

Метод `.filter()` **возвращает** QuerySet с объектами, которые соответствуют заданным условиям.

```python
<Модель>.objects.filter(<свойство>__<модификатор>=<значение для фильтрации>) 
```

Например, такой SQL-запрос…

```sql
SELECT *
FROM ice_cream_icecream
WHERE title LIKE '%эскимо%'; 
```

…в Django ORM записывается так:

```python
IceCream.objects.filter(title__contains='эскимо')  
```

> Самый распространённый модификатор, применяемый в методе `filter()` — `__exact`, «точное совпадение». Если в выражении сравнения модификатор не указан явно — то по умолчанию применяется `__exact`.

Вернёмся к задаче: выведем на главную только те сорта мороженого, которые администратор отметил галкой «На главную». Для этого отфильтруем те объекты модели `IceCream`, у которых значение поля `is_on_main` равно `True`:

```python
IceCream.objects.filter(is_on_main__exact=True)
# Модификатор __exact используется по умолчанию,
# можно его не указывать.
# Так тоже сработает:
# IceCream.objects.filter(is_on_main=True)

# Оба варианта приведут к одинаковому результату, 
# но второй читается проще, поэтому так все и пишут. 
```

Разместим этот вызов во view-функции `index()`:

```python
# homepage/views.py
from django.shortcuts import render

from ice_cream.models import IceCream

def index(request):
    template_name = 'homepage/index.html'
    # Заключаем вызов методов в скобки
    # (это стандартный способ переноса длинных строк в Python);
    # каждый вызов пишем с новой строки, так проще читать код:
    ice_cream_list = IceCream.objects.values(
            'id', 'title', 'description'
        # Верни только те объекты, у которых в поле is_on_main указано True:
        ).filter(is_on_main=True)
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template_name, context) 
```

После GET-запроса к главной странице проекта будет отправлен такой SQL-запрос:

```sql
SELECT "ice_cream_icecream"."id",
       "ice_cream_icecream"."title",
       "ice_cream_icecream"."description"
FROM "ice_cream_icecream"
WHERE "ice_cream_icecream"."is_on_main" 
```

Задача решена:

![](https://pictures.s3.yandex.net/resources/S3.2_40_1679045396.png)

### **Метод** exclude()

Для **исключения** объектов, соответствующих определённому условию, применяют метод `.exclude()`; в SQL ему соответствует комбинация операторов `WHERE NOT ...`:

```python
<Модель>.objects.exclude(<свойство>__<модификатор>=<значение для фильтрации>) 
```

В модели `IceCream` предусмотрен флаг `is_published` — показывать ли запись на сайте. Если в поле `is_published` установлено значение `False` — эту запись нужно исключить из выборки, не показывать её ни на одной странице проекта, в том числе и на главной.

Через метод `.exclude()` настроим запрос так, чтобы в QuerySet **не попали** те записи, у которых в поле `is_published` стоит `False`:

```python
...

def index(request):
    template_name = 'homepage/index.html'
    ice_cream_list = IceCream.objects.values(
            'id', 'title', 'description'
        # Исключи те объекты, у которых is_published=False:
        ).exclude(is_published=False)
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template_name, context) 
```

Теперь для формирования главной страницы будет отправляться такой запрос (с двойным отрицанием):

```sql
SELECT "ice_cream_icecream"."id",
       "ice_cream_icecream"."title",
       "ice_cream_icecream"."description"
FROM "ice_cream_icecream"
WHERE (NOT (NOT "ice_cream_icecream"."is_published")) 
```

## Работа с датами

Для работы с датами применяются специальные модификаторы.

Предположим, в каком-нибудь проекте блога есть модель `Pоst` (публикация) и одно из полей этой модели — дата публикации.

```python
class Post(models.Model):
    pub_date = models.DateTimeField('Дата публикации')
    ... 
```

Востребованная задача для таких проектов — получить подборку записей, опубликованных за определённый диапазон времени. Для решения этой задачи в Django ORM можно применить модификатор **range** — проверить значение даты на вхождения в диапазон дат.

Получим публикации, созданные в диапазоне с 1 января 1890 до 31 марта 1895 (нашему блогу почти полтора века!):

```python
import datetime

...

def filtered_date(request):
    ...    
    start_date = datetime.date(1890, 1, 1)
    end_date = datetime.date(1895, 3, 31)
    Post.objects.filter(pub_date__range=(start_date, end_date))
    # SQL-версия запроса: WHERE pub_date BETWEEN '1890-01-01' AND '1895-03-31';
    return render(request, template_name, context) 
```

Можно проверять значение поля только по части даты. Например, можно отфильтровать только те записи, которые опубликованы

- 13 числа (любого месяца и года),
- в мае (в любое число и в любой год),
- в пятницу,
- …в какие-то ещё дни или диапазоны дат.

Для таких запросов в Django ORM применяют дополнительные суффиксы `__date`, `__year`, `__month`, `__day`, `__week`, `__week_day`, `__quarter`:

```python
# Условия для конкретной даты:
Post.objects.filter(pub_date__date=datetime.date(1890, 1, 1))
# Ранее первого января 1895 года:
Post.objects.filter(pub_date__date__lt=datetime.date(1895, 1, 1))
# В конкретный год:
Post.objects.filter(pub_date__year=1890)
# В любой год с января по июнь включительно:
Post.objects.filter(pub_date__month__lte=6)
# В первый квартал любого года:
Post.objects.filter(pub_date__quarter=1) 
```


---

### Задания

#### Задание 1/1
##### Описание задания
Используя метод `.filter()` передайте на главную страницу проекта названия и описания только тех сортов мороженого, у которых установлен флаг `is_published`.

##### Подсказка
Не изменяйте метод `.values()`.

##### Решение задания
```python
# homepage/views.py
from django.shortcuts import render

from ice_cream.models import IceCream


def index(request):
    template = 'homepage/index.html'
    ice_cream_list = IceCream.objects.values('id', 'title', 'description').filter(is_published=True)
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template, context)
```

Проверено: метод `.filter()` работает! Теперь администратор расставляет галочки «Опубликовано» в админке не просто для красоты: они влияют на содержание страницы!