# Работа с базой данных из Python

Работать с базой данных можно посредством «чистых» SQL-запросов, как это было в прошлых уроках, но есть другой подход: можно отправлять SQL-запросы из кода на Python.

«Подружить» python-программу и СУБД SQLite поможет библиотека [sqlite3](https://docs.python.org/3/library/sqlite3.html): с её помощью можно настроить соединение и отправлять запросы к БД. Устанавливать эту библиотеку не нужно: она встроена в Python и доступна для импорта.

Для начала нужно создать базу данных SQLite; это тоже можно сделать прямо из python-кода.

## Создание базы данных и таблиц

Логика, по которой программа работает с базой данных, в общем виде выглядит так:

1. Подключиться к базе данных, «создать соединение».
2. Подготовить SQL-запросы.
3. Выполнить запросы.
4. Закрыть соединение с БД.

Например, вот как будет выглядеть код для создания таблиц `video_products` и `directors` в файле базы данных _db.sqlite_:

Скопировать кодPYTHON

```python
import sqlite3

# Если в текущей директории нет файла db.sqlite - 
# он будет создан; одновременно будет создано и соединение с базой данных.
# Если файл существует, метод connect просто подключится к базе.
con = sqlite3.connect('db.sqlite')

# Создаём специальный объект cursor для работы с БД.
# Вся дальнейшая работа будет вестись через методы этого объекта.
cur = con.cursor()

# Готовим SQL-запросы.
# Для читаемости запрос обрамлён в тройные кавычки и разбит построчно.
query_1 = '''
CREATE TABLE IF NOT EXISTS directors(
    id INTEGER PRIMARY KEY,
    full_name TEXT,
    birth_year INTEGER
);
'''
query_2 = '''
CREATE TABLE IF NOT EXISTS video_products(
    id INTEGER PRIMARY KEY,
    title TEXT,
    product_type TEXT,
    release_year INTEGER
);
'''

# Применяем запросы.
cur.execute(query_1)
cur.execute(query_2)

# Закрываем соединение с БД.
con.close() 
```

- Инструкция `con = sqlite3.connect('db.sqlite')` создаёт подключение к базе данных, указанной в аргументе метода `.connect()`. Если по заданному пути нет файла базы данных с таким именем — никакой ошибки не возникнет: файл базы данных будет создан автоматически.
- Метод `execute()` принимает одиночный SQL-запрос в виде python-строки, заключённой в тройные кавычки. Нужно создать две таблицы — значит, вызываем метод `execute()` дважды.
- Условие `IF NOT EXISTS` проверяет, нет ли в БД таблицы с переданным в запросе названием. Если такой таблицы нет — сработает инструкция `CREATE`, и таблица будет создана.

> В базе данных SQLite не может быть двух таблиц с одинаковым названием. Поэтому перед созданием таблицы нужно установить условие `IF NOT EXISTS`. В результате новая таблица будет создана только в том случае, если таблицы с таким именем в базе нет.

Если убрать из кода условие `IF NOT EXISTS`, то в первый раз в пустой БД всё сработает как надо — в базе появятся таблицы `video_products` и `directors`; а вот при втором запуске программа упадёт с сообщением `OperationalError: table video_products already exists`. До создания второй таблицы дело не дойдёт.

Выполнение скрипта приведёт к созданию базы данных в файле _db.sqlite_. В этой базе будет создано две пустые таблицы:

![](https://pictures.s3.yandex.net/resources/S3.2_151_1678192635.png)

### Резидентные базы

Базу данных можно создать не в файле, а в памяти компьютера; такие базы называют **резидентными**.

Резидентная база создаётся так:

Скопировать кодPYTHON

```python
con = sqlite3.connect(':memory:') 
```

После закрытия соединения резидентная база данных удаляется из памяти. Такие базы могут быть полезны для отладки и тестирования кода.

## Несколько SQL-запросов сразу

Для одновременного выполнения нескольких SQL-запросов в модуле **sqlite3** есть метод `executescript()`. С его помощью запросы на создание двух таблиц можно записать компактнее:

Скопировать кодPYTHON

```python
...

query = '''
CREATE TABLE IF NOT EXISTS directors(
    id INTEGER PRIMARY KEY,
    full_name TEXT,
    birth_year INTEGER
);

CREATE TABLE IF NOT EXISTS video_products(
    id INTEGER PRIMARY KEY,
    title TEXT,
    product_type TEXT,
    release_year INTEGER
);
'''

cur.executescript(query)

... 
```

Если вы решите создать отдельный файл _test_sql.py_ и потестировать код из листингов — никто не осудит вас за это.

## Заполнение таблицы: INSERT

Теперь заполним таблицу данными; сделаем это с помощью того же метода `execute()`, но на этот раз передадим в него команду `INSERT` с нужными данными:

Скопировать кодPYTHON

```python
...

query = '''
    INSERT INTO video_products(id, title, product_type, release_year)
    VALUES (1, 'Весёлые мелодии', 'Мультсериал', 1930);
'''
cur.execute(query)
con.commit()
con.close() 
```

В метод `execute()` можно было бы передать и обычную f-строку с соответствующими параметрами, однако такой синтаксис небезопасен и может стать причиной взлома через механизм [SQL-инъекций](https://docs.python.org/3/library/sqlite3.html#how-to-use-placeholders-to-bind-values-in-sql-queries).

Для защиты от попыток взлома используется специальный синтаксис: в метод `execute()` значения полей можно передавать в виде кортежа.

Для этого:

- в первом аргументе передаётся запрос `INSERT` с количеством ячеек таблицы; ячейки обозначаются вопросительными знаками через запятую; например, четыре вопросительных знака обозначают четыре ячейки;
- во втором аргументе передаётся кортеж со значениями полей. Модуль SQLite поймёт всё с полуслова и разместит значения в соответствующие ячейки.

Добавим в таблицу `video_products` новую запись. В таблице четыре поля; значит, в первом аргументе передаём запрос, где после `VALUES` — четыре вопросительных знака:

Скопировать кодPYTHON

```python
...

cur.execute(
    'INSERT INTO video_products VALUES(?, ?, ?, ?);',
    (1, 'Весёлые мелодии', 'Мультсериал', 1930)
)
... 
```

Данные будут добавлены, а лазейка для злоумышленников будет закрыта.

Кроме того, с помощью подобного синтаксиса можно добавить несколько записей сразу, для этого применяют метод-shortcut `executemany()`.

Первым аргументом в метод `executemany()` передаётся запрос с указанием количества заполняемых ячеек, а вторым — список, каждый элемент которого — это кортеж со значениями полей.

Этот способ позволяет быстро и просто создать несколько записей:

Скопировать кодPYTHON

```python
...

directors = [
    (1, 'Текс Эйвери', 1908),
    (2, 'Роберт Земекис', 1952),
    (3, 'Джерри Чиникей', 1912),
]
video_products = [
    (1, 'Весёлые мелодии', 'Мультсериал', 1930),
    (2, 'Кто подставил кролика Роджера', 'Фильм', 1988),
    (3, 'Безумные мелодии Луни Тюнз', 'Мультсериал', 1931),
    (4, 'Розовая пантера: Контроль за вредителями', 'Мультфильм', 1969)
]

cur.executemany('INSERT INTO directors VALUES(?, ?, ?);', directors)
cur.executemany('INSERT INTO video_products VALUES(?, ?, ?, ?);', video_products)

con.commit()
con.close() 
```

При выполнении запросов на добавление или изменение данных в таблицах, например, при выполнении инструкции `INSERT`, должен вызываться метод `commit()`; если не вызвать этот метод — изменения не будут сохранены в базе данных.

В результате выполнения этого кода три записи будут добавлены в таблицу `directors` и четыре — в таблицу `video_products`.

![](https://pictures.s3.yandex.net/resources/S3.2_161_1678192651.png)