Отсортированная и ограниченная выборка — это удобно, но при работе с базой данных всегда хочется большего. Например — как средствами СУБД посчитать стоимость заказа #35 в интернет-магазине? А как подбить общую стоимость заказов за 17 февраля?

![](https://pictures.s3.yandex.net/resources/S2_136_1682533286.png)

Для решения подобных задач в SQL существуют **агрегирующие** или **агрегатные** (от англ. _aggregate_, «сгруппированный, совокупный») функции. Эти функции **выполняют вычисления** на наборе значений.

Агрегирующая функция возвращает результирующую таблицу, в которой лишь одна колонка и одна запись — результат вычислений. Например, агрегирующая функция **COUNT()** вернёт одно число — количество строк в полученной выборке.

В общем виде запрос с агрегирующей функцией выглядит так:
```sql
SELECT АГРЕГИРУЮЩАЯ_ФУНКЦИЯ(название_поля)    
FROM таблица; 
```

Добавим в таблицу с фильмами столбец `gross`: в нём записаны кассовые сборы фильмов в долларах (по данным Кинопоиска). Для некоторых картин информации о сборах нет, поэтому в графе стоит `NULL` — в языке SQL `NULL` обозначает отсутствие значения (в Python для этого используется `None`).

![](https://pictures.s3.yandex.net/resources/S2_137_1682533300.png)

### COUNT

Агрегирующая функция **COUNT()** (англ. «подсчёт») возвращает количество строк в результирующей выборке.
```sql
SELECT COUNT(gross)
FROM video_products; 
```

Этот запрос переводится с SQL на русский как «Получи все значения из столбца **gross** и пересчитай их». В колонке **gross** есть несколько ячеек без значений (в них записано `NULL`); функция `COUNT()` не будет учитывать эти ячейки при подсчёте — ведь она пересчитывает именно значения.

В результате выполнения этого запроса вернётся результирующая таблица из одного столбца и одной строки; в единственной ячейке этой таблицы будет значение 3.

Для функции `COUNT` возможен особый синтаксис: `COUNT(*)`.
```sql
SELECT COUNT(*)
FROM video_products; 
```

При записи `COUNT(*)` функция подсчитает не количество значений в какой-то колонке, а **количество записей в результирующей выборке**. Вернётся число 10.

Через `COUNT(*)` можно подсчитать число записей в любой выборке, например, с условием `WHERE`.

Ограничим выборку условием `WHERE`:
```sql
SELECT COUNT(*)
FROM video_products
WHERE product_type='Фильм'; 
```

Теперь функция `COUNT(*)` вернёт значение 4 — ведь результирующая таблица содержит только четыре строки.

### MIN и MAX

Эти агрегирующие функции предназначены для поиска максимального или минимального значения в заданном столбце.
```sql
-- ВЫБЕРИ МИНИМАЛЬНОЕ ЗНАЧЕНИЕ в колонке gross:
SELECT MIN(gross)
FROM video_products;
-- Вернёт: 25118063
 
SELECT MAX(gross)
FROM video_products;
-- Вернёт: 156452370  
```

Функции `MIN` и `MAX` также игнорируют `NULL`. Чего нет — то не может быть подсчитано.

> Найти минимальное или максимальное значение можно и без агрегирующих функций — для этого сортируем таблицу по заданному полю и берём первое значение. Но такой запрос будет работать намного дольше, чем агрегатные функции. К тому же при сортировке от меньшего к большему первым значением может оказаться `NULL`, а его никак нельзя назвать «минимальным» — ведь `NULL` означает, что значения просто нет.

### AVG и SUM

Часто требуется получить средние значения и итоговую сумму по какому-то столбцу. SQL может вернуть и такие данные: для этого есть агрегирующие функции AVG (от англ. _average_ «среднее») и SUM (от англ. «сумма»). Эти функции тоже игнорируют `NULL`. Подсчитываемая выборка может быть ограничена с помощью `WHERE`.

**Примеры использования:**
```sql
-- СОСЧИТАЙ СРЕДНЕЕ ЗНАЧЕНИЕ в поле gross для записей,
-- У КОТОРЫХ значение release_year больше 1980
SELECT AVG(gross)
FROM video_products
WHERE release_year > 1980;
-- Вернёт: 146875429.5

SELECT SUM(gross)
FROM video_products
WHERE release_year > 1980;
-- Вернёт: 293750859 
```

На практике **SUM** часто используется для подсчёта итоговой суммы в заказе, а **AVG** — для работы со всевозможными рейтингами.