Отсортированная и ограниченная выборка — это удобно, но при работе с базой данных всегда хочется большего. Например — как средствами СУБД посчитать стоимость заказа #35 в интернет-магазине? А как подбить общую стоимость заказов за 17 февраля?

![](https://pictures.s3.yandex.net/resources/S2_136_1682533286.png)

Для решения подобных задач в SQL существуют **агрегирующие** или **агрегатные** (от англ. _aggregate_, «сгруппированный, совокупный») функции. Эти функции **выполняют вычисления** на наборе значений.

Агрегирующая функция возвращает результирующую таблицу, в которой лишь одна колонка и одна запись — результат вычислений. Например, агрегирующая функция **COUNT()** вернёт одно число — количество строк в полученной выборке.

В общем виде запрос с агрегирующей функцией выглядит так:
<<<<<<< HEAD:Education/Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md

Скопировать код

SQL

```
=======
```sql
>>>>>>> 335713cc75f2671df7efb320d83d056298be94bb:Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md
SELECT АГРЕГИРУЮЩАЯ_ФУНКЦИЯ(название_поля)    
FROM таблица; 
```

Добавим в таблицу с фильмами столбец `gross`: в нём записаны кассовые сборы фильмов в долларах (по данным Кинопоиска). Для некоторых картин информации о сборах нет, поэтому в графе стоит `NULL` — в языке SQL `NULL` обозначает отсутствие значения (в Python для этого используется `None`).

![](https://pictures.s3.yandex.net/resources/S2_137_1682533300.png)

### COUNT

Агрегирующая функция **COUNT()** (англ. «подсчёт») возвращает количество строк в результирующей выборке.
<<<<<<< HEAD:Education/Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md

=======
>>>>>>> 335713cc75f2671df7efb320d83d056298be94bb:Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md
```sql
SELECT COUNT(gross)
FROM video_products; 
```

Этот запрос переводится с SQL на русский как «Получи все значения из столбца **gross** и пересчитай их». В колонке **gross** есть несколько ячеек без значений (в них записано `NULL`); функция `COUNT()` не будет учитывать эти ячейки при подсчёте — ведь она пересчитывает именно значения.

В результате выполнения этого запроса вернётся результирующая таблица из одного столбца и одной строки; в единственной ячейке этой таблицы будет значение 3.

Для функции `COUNT` возможен особый синтаксис: `COUNT(*)`.
<<<<<<< HEAD:Education/Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md

=======
>>>>>>> 335713cc75f2671df7efb320d83d056298be94bb:Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md
```sql
SELECT COUNT(*)
FROM video_products; 
```

При записи `COUNT(*)` функция подсчитает не количество значений в какой-то колонке, а **количество записей в результирующей выборке**. Вернётся число 10.

Через `COUNT(*)` можно подсчитать число записей в любой выборке, например, с условием `WHERE`.

Ограничим выборку условием `WHERE`:
```sql
SELECT COUNT(*)
FROM video_products
WHERE product_type='Фильм'; 
```

Теперь функция `COUNT(*)` вернёт значение 4 — ведь результирующая таблица содержит только четыре строки.

### MIN и MAX

Эти агрегирующие функции предназначены для поиска максимального или минимального значения в заданном столбце.
<<<<<<< HEAD:Education/Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md

=======
>>>>>>> 335713cc75f2671df7efb320d83d056298be94bb:Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md
```sql
-- ВЫБЕРИ МИНИМАЛЬНОЕ ЗНАЧЕНИЕ в колонке gross:
SELECT MIN(gross)
FROM video_products;
-- Вернёт: 25118063
 
SELECT MAX(gross)
FROM video_products;
-- Вернёт: 156452370  
```

Функции `MIN` и `MAX` также игнорируют `NULL`. Чего нет — то не может быть подсчитано.

> Найти минимальное или максимальное значение можно и без агрегирующих функций — для этого сортируем таблицу по заданному полю и берём первое значение. Но такой запрос будет работать намного дольше, чем агрегатные функции. К тому же при сортировке от меньшего к большему первым значением может оказаться `NULL`, а его никак нельзя назвать «минимальным» — ведь `NULL` означает, что значения просто нет.

### AVG и SUM

Часто требуется получить средние значения и итоговую сумму по какому-то столбцу. SQL может вернуть и такие данные: для этого есть агрегирующие функции AVG (от англ. _average_ «среднее») и SUM (от англ. «сумма»). Эти функции тоже игнорируют `NULL`. Подсчитываемая выборка может быть ограничена с помощью `WHERE`.

**Примеры использования:**
<<<<<<< HEAD:Education/Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md

=======
>>>>>>> 335713cc75f2671df7efb320d83d056298be94bb:Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md
```sql
-- СОСЧИТАЙ СРЕДНЕЕ ЗНАЧЕНИЕ в поле gross для записей,
-- У КОТОРЫХ значение release_year больше 1980
SELECT AVG(gross)
FROM video_products
WHERE release_year > 1980;
-- Вернёт: 146875429.5

SELECT SUM(gross)
FROM video_products
WHERE release_year > 1980;
-- Вернёт: 293750859 
```

<<<<<<< HEAD:Education/Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md
На практике **SUM** часто используется для подсчёта итоговой суммы в заказе, а **AVG** — для работы со всевозможными рейтингами.

### Задание 1

В тренажёре заготовлен файл c базой данных `db.sqlite` с таблицей `ice_cream`.

Поля таблицы:

- `is_published`, тип INTEGER (допустимые значения — 0 и 1; в Python это поле будет интерпретировано как `bool`)
- `is_on_main`, тип INTEGER (допустимые значения — 0 и 1; в Python это поле будет интерпретировано как `bool`)
- `title`, тип TEXT
- `description`, тип TEXT
- `category`, тип TEXT
- `price`, тип REAL

Напишите запрос, который найдёт стоимость самого дешёвого мороженого. Цены хранятся в поле `price` таблицы `ice_cream`. Результат выведите в консоль.

```python
import sqlite3

con = sqlite3.connect('db.sqlite')
cur = con.cursor()

# Напишите SQL запрос в строке.
results = cur.execute('''
SELECT MIN(price)
FROM ice_cream;
''')

for result in results:
    print(result)

con.close()
```

### Задание 2
Напишите запрос, который подсчитает в таблице `ice_cream` среднюю стоимость тех сортов мороженого, где в поле `category` стоит значение «Экзотическое». Результат выведите в консоль.

```python
import sqlite3

con = sqlite3.connect('db.sqlite')
cur = con.cursor()

# Напишите SQL запрос в строке.

results = cur.execute('''
SELECT AVG(price)
FROM ice_cream
WHERE category='Экзотическое';
''')

for result in results:
    print(result)

con.close()
```

### Задание 3

В таблице `ice_cream`

- сорта мороженого, которые должны быть видны на сайте (опубликованы), обозначаются значением `1` в поле `is_published` (в этом поле Python интерпретирует значение `1` как `True`);
- сорта мороженого, которые должны быть выведены на главную страницу проекта, обозначаются значением `1` в поле `is_on_main` (в этом поле Python интерпретирует значение `1` как `True`).

Напишите запрос, который сосчитает суммарную стоимость **опубликованных на главной странице** сортов мороженого — тех, у каких одновременно есть статусы «**опубликовано»** и **«показать на главной»**. Результат выведите в консоль.

```python
import sqlite3

con = sqlite3.connect('db.sqlite')
cur = con.cursor()

# Напишите SQL запрос в строке.

results = cur.execute('''
SELECT SUM(price)
FROM ice_cream
WHERE is_published=True
AND is_on_main=True;
''')

for result in results:
    print(result)

con.close()
```
=======
На практике **SUM** часто используется для подсчёта итоговой суммы в заказе, а **AVG** — для работы со всевозможными рейтингами.
>>>>>>> 335713cc75f2671df7efb320d83d056298be94bb:Яндекс практикум - Современные информационные технологии/Базы данных/I. Введение в базы данных/8. Агрегирующие функции.md
