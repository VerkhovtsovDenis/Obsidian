# Отношения между таблицами. «Многие ко многим»

У каждой картины есть автор. Но если в живописи два автора одной картины — это редкость, то несколько режиссёров одного фильма — это обычное дело. Публика хочет знать имена режиссёров, так что добавим их в нашу базу данных.

Для начала опишем условия:

- У фильма может быть один или несколько режиссёров.
- Режиссёр может снять один или несколько фильмов.

Это классический пример связи N:M, «многие ко многим».

Соберём имена режиссёров в отдельную таблицу:

![](https://pictures.s3.yandex.net/resources/S2_141_1_1682533873.png)

Немного расширим список фильмов и сопоставим их названия с `id` режиссёров:

![](https://pictures.s3.yandex.net/resources/S2_160_1682533887.png)

![](https://pictures.s3.yandex.net/resources/S02_227_1685551410.png)

Для сериала «Она написала убийство» в нашей базе указано целых три режиссёра, и чтобы указать их — в поле `director_id` пришлось бы перечислить несколько id. Однако в одной ячейке типа INTEGER должно храниться только одно число.

На практике такую связь организуют через промежуточную таблицу: в ней сопоставляют идентификаторы записей из связываемых таблиц.

![](https://pictures.s3.yandex.net/resources/S02_232_1_1685551419.png)

Промежуточная таблица названа по именам таблиц, которые через неё связаны: **directors__video_products**.

Она содержит

- поле `director_id` типа `FOREIGN KEY`, ссылающееся на колонку `id` в таблице **directors**;
- поле `video_product_id` типа `FOREIGN KEY`, ссылающееся на колонку `id` в таблице **video_products**.

В итоге каждая запись промежуточной таблицы ссылается на записи в таблицах **directors** и **video_products**. Связь построена!

![](https://pictures.s3.yandex.net/resources/S2_161_1682533906.png)

Любой режиссёр может снять один фильм только один раз. Значит, каждая пара «фильм — режиссёр» уникальна в пределах таблицы. А уникальные значения могут служить первичными ключами записей.

Поэтому здесь в качестве `PRIMARY KEY` используется сочетание `(director_id, video_product_id)` — эта пара уникальна в пределах таблицы. Сочетание значений этих полей служит **композитным** первичным ключом.

Создать таблицу с композитным первичным ключом можно так:

```sql
CREATE TABLE IF NOT EXISTS video_products(
    id INTEGER PRIMARY KEY,
    title TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS directors(
    id INTEGER PRIMARY KEY,
    full_name TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS directors__video_products(    
    director_id INTEGER NOT NULL,
    video_product_id INTEGER NOT NULL,
    -- Пару полей назначаем композитным первичным ключом:
    PRIMARY KEY (director_id, video_product_id),
    FOREIGN KEY(director_id) REFERENCES directors(id),
    FOREIGN KEY(video_product_id) REFERENCES video_products(id)
); 
```

Вольный перевод SQL-запроса на русский язык:

- создаём таблицы **video_products** и **directors** и промежуточную таблицу **directors__video_products**;
- в промежуточной таблице указываем связь между записями двух таблиц;
- в таблице **directors__video_products** создаём композитный первичный ключ из полей `director_id` и `video_product_id`; при этом решается и вторая задача: теперь каждая пара полей будет уникальна в пределах таблицы, и никто не сможет повторно связать фильм с режиссёром.

Теперь любую запись из таблицы **directors** можно связать с несколькими фильмами из **video_products**, а фильм можно связать с несколькими режиссёрами.