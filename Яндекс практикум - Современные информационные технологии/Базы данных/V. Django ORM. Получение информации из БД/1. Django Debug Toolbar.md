Теперь вы будете писать код, который формирует запросы к базе данных. Для решения одной и той же задачи можно отправить один запрос, а можно — несколько десятков. Лучше — меньше: ведь при большом количестве пользователей лишние запросы создадут ненужную нагрузку на БД.

Чтобы сравнить, в каком случае отправляется больше запросов, а каком — меньше, установите в проект приложение [django-debug-toolbar](https://django-debug-toolbar.readthedocs.io/en/latest/) (**DjDT**). Оно покажет, какие запросы отправляет ORM и что вы получаете из базы данных.

Подключить его — дело трёх минут:

- устанавливаете приложение через pip,
- регистрируете приложение в списке INSTALLED_APPS,
- подключаете к проекту urls этого приложения,
- в список MIDDLEWARE добавляете DebugToolbarMiddleware.

Готово!

### Middleware

В дословном переводе **middleware** — это «промежуточное программное обеспечение»; middleware обрабатывает:

- запросы перед тем, как они попадают во view-функцию
- и ответы view-функции — перед тем, как они отправятся пользователю.

В проекте может быть несколько middleware, и в общем виде **запрос** в Django проходит такой путь:

Скопировать код

```
[...] -> middleware1 -> middleware2 -> middleware_n -> view-функция 
```

**Ответ** view-функции снова проходит через те же middleware, но в обратном порядке:

Скопировать код

```
view-функция -> middleware_n -> middleware2 -> middleware1 -> [...] 
```

Человек входит в офисное здание: проходит ресепшн, пост охраны, поднимается на лифте, добирается до нужного офиса; при этом

- на ресепшн ему дают схему здания или пончик,
- охрана сообщает в офис «к вам посетитель»,
- в лифте срабатывает счётчик: «это 583 посетитель».

В офисе человек… ну, допустим, успешно проходит собеседование — и возвращается:

- едет в лифте (а там срабатывает какой-то другой счётчик), едет на первый этаж,
- проходит пост охраны (охрана отмечает: «посетитель ушёл»),
- минует ресепшн — и идёт по своим делам.

На каждом этапе была выполнена какая-то работа; на обратном пути человек прошёл те же этапы в обратном порядке, и при этом была выполнена ещё какая-то работа; эта работа была связана с его появлением в здании, но напрямую его не затронула.

Вообще-то человек — это был запрос, здание — это Django, а ресепшн, охрана и лифт — это были middleware.

Middleware выполняют какую-то работу, связанную с запросами и ответами. Например, **middleware DjDT** обрабатывает запросы и ответы — и за счёт этого выводит на страницу массу полезной информации.

При развёртывании проекта в этом списке уже есть несколько middleware. Django хранит их список в _settings.py_ в константе `MIDDLEWARE`. Удалять их не рекомендуется; в этот список можно добавлять собственные middleware.

Скопировать код

PYTHON

```
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
] 
```

Middleware обрабатывают запрос по очереди, в том порядке, в каком они перечислены в этом списке.

### Устанавливаем Django Debug Toolbar

Сторонние приложения устанавливаются в виртуальное окружение через менеджер пакетов **pip**, вы уже работали с ним. Активируйте виртуальное окружение и выполните команду

Скопировать код

BASH

```
pip install django-debug-toolbar==3.8.1 
```

Сразу добавьте **DjDT** в список пакетов, используемых в проекте. Список зависимостей хранят в файле **requirements.txt**, как правило _—_ в корневой папке проекта.

Для обновления списка пакетов **перейдите в корневую папку проекта** и (при запущенном виртуальном окружении конечно же) выполните команду

Скопировать код

BASH

```
pip freeze > requirements.txt 
```

Менеджер pip создаст список всех пакетов, установленных в проекте; список будет сохранён в файл _requirements.txt_; в этом списке окажется и Django Debug Toolbar.

Если вы ошиблись, и файл создался в другой папке — не беда. Перенесите его в корневую папку, удалив старый файл _requirements.txt_.

В любом случае у вас должна получиться такая структура:

Скопировать код

```tree

├── anfisa_for_friends/
|   ├── about/
|   ├── anfisa_for_friends/
|   ├── core/
|   ├── homepage/
|   ├── ice_cream/
|   ├── static_dev/
|   ├── templates/
|   ├── db.sqlite3 
|   ├── db.json                  
|   └── manage.py
├── .gitignore
├── README.md
├── requirements.txt  <-- Файл с зависимостями разместите тут 
├── .git/
└── venv/ 
```

---
> После установки любого нового пакета выполняйте `pip freeze > requirements.txt`, тогда любой программист сможет легко установить зависимости, нужные в проекте.
---

После установки приложения зарегистрируйте и настройте приложение **DjDT** в файле _anfisa_for_friends/settings.py_:

Скопировать код

PYTHON

```
# anfisa_for_friends/settings.py

...

INSTALLED_APPS = [
    # В проекте уже зарегистрировано несколько приложений.
    ...
    # Регистрируем новое приложение в проекте:
    # обязательно ниже, чем django.contrib.staticfiles.
    'debug_toolbar',
]

# MIDDLEWARE — список промежуточных программных слоёв, подключённых к проекту.
# DebugToolbarMiddleware будет обрабатывать информацию из запросов
# и отображать её в панели Django Debug Toolbar.
# Добавьте DebugToolbarMiddleware в самый конец списка.
MIDDLEWARE = [
    ...
    'debug_toolbar.middleware.DebugToolbarMiddleware',
]

# Добавьте в settings.py эту константу, чтобы DjDT знал,
# запросы с каких IP он должен обрабатывать.
INTERNAL_IPS = [
    '127.0.0.1',
] 
```

Последний штрих: в головной файл _anfisa_for_friends/urls.py_ добавьте новое правило для режима отладки:

Скопировать код

PYTHON

```
# anfisa_for_friends/urls.py
# Импортируем информацию из настроек.

...

from django.conf import settings

urlpatterns = ...

# Если проект запущен в режиме разработки...
if settings.DEBUG:
    import debug_toolbar
    # Добавить к списку urlpatterns список адресов из приложения debug_toolbar:
    urlpatterns += (path('__debug__/', include(debug_toolbar.urls)),) 
```

После подключения и настройки DjDT дизайн страниц изменится: появится боковое меню с несколькими подразделами. Во вкладке SQL можно увидеть запросы, на основе которых формируется запрошенная страница.

Например, вот запрос, который формирует страницу по адресу `127.0.0.1:8000/admin/`:

![](https://pictures.s3.yandex.net/resources/S3.2_34_1679044276.png)

Большинство Django-программистов подключают **DjDT** в самом начале работы над проектом: это упрощает разработку и помогает избежать многих проблем. Обычному пользователю эта панель не нужна, поэтому **DjDT** настраивают так, чтобы она была видна только в режиме разработки (при настройке `DEBUG = True` в _settings.py_).

## На заметку

Побольше узнать про Django Middleware можно [в документации Django](https://docs.djangoproject.com/en/3.2/topics/http/middleware/).