На главной должны отображаться те сорта мороженого, которые отвечают одновременно двум условиям:

- `is_published = True`
- `is_on_main = True`

Значит, условия нужно объединить. Рассказываем, как это делать.

## Объединение условий

Объединить несколько условий в методе `.filter()` можно через запятую.

Чтобы view-функция получила объекты, которые соответствуют сразу двум условиям, её код должен быть примерно таким:

Скопировать код

PYTHON

```
# homepage/views.py
from django.shortcuts import render

from ice_cream.models import IceCream

def index(request):
    template = 'homepage/index.html'
    ice_cream_list = IceCream.objects.values(
        'id', 'title', 'description'
    ).filter(
        is_published=True, is_on_main=True  # Два в одном!
    )
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template, context) 
```

В SQL-запросе условия будут объединены через `AND`:

Скопировать код

SQL

```
SELECT "ice_cream_icecream"."id",
       "ice_cream_icecream"."title",
       "ice_cream_icecream"."description"
FROM "ice_cream_icecream"
WHERE ("ice_cream_icecream"."is_on_main" AND "ice_cream_icecream"."is_published") 
```

Задача решена!

В некоторых туториалах или в другой литературе вы встретите объединение запросов, записанное вот так:

Скопировать код

PYTHON

```
IceCream.objects.filter(is_published=True).filter(is_on_main=True) 
```

Так тоже сработает. Но лучше писать через запятую: меньше кода — проще читать.

## Q-объекты: запросы с операторами NOT, AND и OR

В запросах может быть недостаточно перечисления условий через запятую: иногда требуется составить более сложный комбинированный запрос. В Django ORM для этого применяют **Q-объекты**.

В **Q-объект** передаётся название поля, модификатор и значение для фильтрации, а сами объекты объединяются в запрос логическими операторами: `~` (NOT), `&` (AND) и `|` (OR):

![](https://pictures.s3.yandex.net/resources/S02_13_05_03_1682500531.png)

Вот пример view-функции, которая выбирает объекты по двум условиям:

Скопировать код

PYTHON

```
# homepage/views.py
# Для применения Q-объектов их нужно импортировать:
from django.db.models import Q
from django.shortcuts import render

from ice_cream.models import IceCream

def index(request):
    template_name = 'homepage/index.html'
    ice_cream_list = IceCream.objects.values(
        'id', 'title', 'description'
    ).filter(
        # Делаем запрос, объединяя два условия
        # через Q-объекты и оператор AND:
        Q(is_published=True) & Q(is_on_main=True)
    )
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template_name, context) 
```

## Примеры запросов с логическими операторами

**Логический оператор AND**

**SQL**: получаем записи, у которых значения полей `is_on_main` и `is_published` равны `TRUE`:

Скопировать код

SQL

```
SELECT "ice_cream_icecream"."id"
FROM "ice_cream_icecream"
WHERE ("ice_cream_icecream"."is_on_main" AND "ice_cream_icecream"."is_published") 
```

Для такого запроса в ORM есть несколько вариантов:

Скопировать код

PYTHON

```
# Вариант 1, через запятую в аргументах метода .filter():
IceCream.objects
.values('id')
.filter(is_published=True, is_on_main=True)

# Вариант 2, через Q-объекты:
IceCream.objects
.values('id')
.filter(Q(is_published=True) & Q(is_on_main=True))

# Вариант 3, дважды вызываем метод .filter();
# так обычно не пишут, но этот вариант тоже встречается:
IceCream.objects
.values('id')
.filter(is_published=True).filter(is_on_main=True) 
```

**Логический оператор OR**

**SQL**: получаем записи, у которых поле `is_on_main` ИЛИ поле `is_published` равно `True`:

Скопировать код

SQL

```
SELECT "ice_cream_icecream"."id"       
FROM "ice_cream_icecream"
WHERE ("ice_cream_icecream"."is_on_main" OR "ice_cream_icecream"."is_published") 
```

Django ORM:

Скопировать код

PYTHON

```
# Можно так, через Q-объекты:
IceCream.objects
.values('id')
.filter(Q(is_published=True) | Q(is_on_main=True))

# А можно и так - более многословно, но зато без Q-объектов:
IceCream.objects.values('id').filter(is_published=True) 
| IceCream.objects.values('id').filter(is_on_main=True) 
```

**Логический оператор NOT**

**SQL**: получаем записи, у которых поле `is_published` равно `True` и одновременно поле `is_on_main` не равно `False` (НЕ НЕ равно `True`):

Скопировать код

SQL

```
 SELECT "ice_cream_icecream"."id",
 FROM "ice_cream_icecream"
 WHERE ("ice_cream_icecream"."is_published" 
        AND NOT (NOT "ice_cream_icecream"."is_on_main") 
```

Django ORM:

Скопировать код

PYTHON

```
# Лучше так:
IceCream.objects
.values('id')
.filter(Q(is_published=True) & ~Q(is_on_main=False))

# Но сработает и так:
IceCream.objects
.values('id')
.filter(is_published=True)
.exclude(is_on_main=False) 
```

## Приоритет выполнения

Логические операторы имеют разный приоритет выполнения: оператор `NOT` имеет самый высокий приоритет и выполняется первым, следующий по приоритету — оператор `AND`, а самый последний — оператор `OR`. Для объединения условий в группу используются скобки `()`.

У дизайнеров есть нелюбимое выражение: «поиграйте со шрифтами»; это переводится как «попробуйте разные шрифты и выберите лучший для дизайна».

У бэкендеров — свои игрушки, и уж если играть — то с запросами: протестировать варианты и посмотреть, что получится. Попробуйте, вдруг эта игра вам понравится.

## Играем с запросами, решаем задачку

В проекте «Анфиса для друзей», развёрнутом на вашем компьютере, во view-функции `index()` напишите такой запрос, чтобы в контекст главной страницы были переданы сорта мороженого со значением `True` в поле `is_published` и у которых

- либо в поле `is_on_main` записано значение `True`;
- либо в названии есть слово «пломбир» (даже если в поле `is_on_main` у этого объекта стоит `False`).

![](https://pictures.s3.yandex.net/resources/S02_13_05_02_1682500550.png)

Для решения этой задачи у вас есть полный арсенал: методы `.filter()` и `.values()` с набором модификаторов, Q-объекты и целая коллекция логических операторов.

Когда вы напишете правильный код во view-функции, в Django Debug Toolbar должен получиться такой запрос:

Скопировать код

SQL

```
SELECT "ice_cream_icecream"."id",
       "ice_cream_icecream"."title",
       "ice_cream_icecream"."description"
FROM "ice_cream_icecream"
WHERE (("ice_cream_icecream"."is_on_main" AND "ice_cream_icecream"."is_published") OR ("ice_cream_icecream"."title" LIKE '''%пломбир%''' ESCAPE '\' AND "ice_cream_icecream"."is_published")) 
```

Есть и другой вариант решения, при котором SQL-запрос будет таким:

Скопировать код

SQL

```
SELECT "ice_cream_icecream"."id",
       "ice_cream_icecream"."title",
       "ice_cream_icecream"."description"
FROM "ice_cream_icecream"
WHERE ("ice_cream_icecream"."is_published" AND ("ice_cream_icecream"."is_on_main" OR "ice_cream_icecream"."title" LIKE '''%пломбир%''' ESCAPE '\')) 
```

Django ORM автоматически добавляет оператор `ESCAPE` во все SQL-запросы `LIKE`; этот оператор указывает, какой текстовый символ применяется для экранирования специальных символов в тексте. Django ORM всегда добавляет этот оператор, даже если в конкретном запросе экранирование не требуется. Оператор `ESCAPE` будет вставлен в SQL-запрос автоматически, в Python его описывать не нужно.

Немножко подробностей про экранирование

После оператора `ESCAPE` указывают символ, которым в строке экранируются символы `_` и `%` в SQL-запросах `LIKE`, если они должны быть частью строки, а не спецсимволами SQL.

Это примерно то же, что и экранирование кавычки `'` с помощью обратного слеша `\` в Python-строках. Без экранирования программа решит, что, например, в фамилии `О'Тулл` одиночная кавычка — это конец строки. Тут-то всё и сломается. А экранирование «объясняет» программе, что следующий за «экраном» символ — это тоже часть строки. Запустите код `print('Привет, мистер О\'Тулл')` и посмотрите, как это работает.

Чтобы убедиться, что запрос работает правильно, — зайдите в админку и снимите флаг «На главную» с мороженого _Эскимо_.

![](https://pictures.s3.yandex.net/resources/S02_13_05_01_1682500575.png)

Попробуйте установить флаги в других комбинациях и посмотрите, как работает ваш запрос.

Вот как может выглядеть view-функция, которая решит поставленную задачу:

Скопировать код

PYTHON

```
from django.db.models import Q
from django.shortcuts import render

from ice_cream.models import IceCream

def index(request):
    template_name = 'homepage/index.html'
    # Для переноса длинной строки замыкаем её в скобки.
    # Будьте внимательны.
    ice_cream_list = IceCream.objects.values(
        'title', 'description'
    ).filter(
        Q(is_on_main=True)
        & Q(is_published=True)
        | Q(title__contains='пломбир')
        & Q(is_published=True)
    )
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template_name, context) 
```

Django ORM преобразовал код в SQL-запрос и расставил в нём скобки, используя приоритетность AND и OR.

С технической точки зрения в приведённом Python-коде скобки не нужны, но чтобы код читался проще — лучше объединить скобками части запроса в группы:

Скопировать код

PYTHON

```
.filter(
    (Q(is_on_main=True) & Q(is_published=True))
    | Q(title__contains='пломбир') & Q(is_published=True)
) 
```

Запрос останется таким же, а читать его станет проще.

Неплохо поиграли. Чтобы в дальнейших уроках ваши результаты запросов не отличались от тех, что будут в теории, зайдите в админку и вновь отметьте флагом «На главную» мороженое _Эскимо_.
