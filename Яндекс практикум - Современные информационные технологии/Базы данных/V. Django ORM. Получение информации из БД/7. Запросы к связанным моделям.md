С запросами к одной таблице разобрались, настало время задач посложнее. На главной странице покажем, к какой категории относится каждый вид мороженого. Для этого нужно получить из базы не только атрибуты объектов `IceCream`, но и данные из связанной модели `Category`.

## Проблема лишних запросов

В Django ORM предусмотрен простой способ обращения к связанным объектам. Можно запросить атрибут объекта, ссылающийся на другую модель — и прямо в HTML-шаблоне получить значения полей связанного объекта — через точечную нотацию. Попробуем решить поставленную задачу именно этим способом.

Во view-функции `index()` приложения **homepage** получим QuerySet с объектами `IceCream` и передадим его в HTML-шаблон:

```python
# homepage/views.py

...

def index(request):
    template_name = 'homepage/index.html'

    ice_cream_list = IceCream.objects.all()

    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template_name, context) 
```

В объектах модели `IceCream` есть атрибут `category`, ссылающийся на объект модели `Category`, а у объектов модели `Category` есть атрибут `title`.

Выведем название категории в шаблон через точечную нотацию — `ice_cream.category.title`:

```django
<!-- templates/homepage/index.html -->

...

{% block content %}
  <h1 class="pb-2 mb-0">Главная страница</h1>
  
  {% for ice_cream in ice_cream_list %}  
    <h3>{{ ice_cream.title }} ID: {{ ice_cream.id }}</h3>
    <!-- Выведем название категории -->
    <p>Категория: {{ ice_cream.category.title }}</p>
  {% endfor %}
{% endblock %} 
```

Работает!

![](https://pictures.s3.yandex.net/resources/S3.2_46_1679048543.png)

Давайте посмотрим, какие SQL-запросы отправляются при запросе к этой странице:

![](https://pictures.s3.yandex.net/resources/S3.2_47_1679048595.png)

Двенадцать запросов — это много. Сейчас дела обстоят так: первым запросом Django ORM получает все объекты `IceCream`, а потом для каждого сорта мороженого отправляется дополнительный запрос, который возвращает название его категории (ведь категория запрошена в шаблоне, но не получена в первом запросе).

![](https://pictures.s3.yandex.net/resources/S02_230_1679048680.png)

Отправляется по одному дополнительному запросу на каждый полученный сорт мороженого! В нашем запросе лишь одиннадцать объектов. А что, если их будет тысяча? А если десять тысяч? Нет, так нельзя, это брак в работе: лишние запросы — лишняя нагрузка на базу данных.

Оптимизировать запросы: из двенадцати сделать один. В этом поможет `JOIN`. Инструкция `JOIN` позволяет «присоединить» к запрошенной таблице другую, связанную с первой через Foreign Key. В результате можно в одном запросе получить данные из двух таблиц так, как если бы это была одна таблица.

В Django ORM тоже есть способы делать JOIN-запросы: с помощью метода `.values()` или с помощью `.select_related()`.

## JOIN c помощью метода .values()

Метод `.values()` может вернуть не только поля запрошенной модели, но и значения полей модели, которая связана с запрошенной:

```python
ice_cream_list = IceCream.objects.values('id', 'title', 'category__title')
# values(..., '<поле fk>__<поле в модели, связанной по fk>') 
```

В аргументе метода `.values()` передаётся имя атрибута, где хранится внешний ключ (`category` в приведённом примере), и через двойное нижнее подчёркивание — название того поля связанной модели, значение которого нужно получить.

Подобный синтаксис применяется и в шаблоне для вывода значения поля из связанной модели:

```django
{% for ice_cream in ice_cream_list %}
  <h3>{{ ice_cream.title }} ID: {{ ice_cream.id }}</h3>
  <p>Категория: {{ ice_cream.category__title }}</p>
{% endfor %}  
```

Сгенерированная веб-страница ничем не будет отличаться от предыдущего варианта:

![](https://pictures.s3.yandex.net/resources/S3.2_48_1679048772.png)

А вот в Django Debug Toolbar разница будет очень заметна: вместо двенадцати запросов будет лишь один:

```sql
SELECT "ice_cream_icecream"."id",
       "ice_cream_icecream"."title",       
       "ice_cream_category"."title"
 FROM "ice_cream_icecream"
 INNER JOIN "ice_cream_category"
    ON ("ice_cream_icecream"."category_id" = "ice_cream_category"."id") 
```

Выигрыш налицо, счёт по запросам — 12:1 в нашу пользу!

> Важный момент: метод `.values()` возвращает список словарей, а не объектов. На практике это означает, что при использовании метода `.values()` в ORM-запросе обратиться к значению связанного поля из шаблона через точечную нотацию не получится. В этом случае нужно использовать синтаксис с двойным подчёркиванием, например, вот так: `{{ ice_cream.category__title }}`.

## JOIN c помощью .select_related()

Другой способ создать JOIN-запрос в Django ORM — вызвать метод `.select_related()`.

Вот его синтаксис:
```python
ice_cream_list = IceCream.objects.select_related('category') 
```

Соответствующий ему SQL запрос тогда будет таким:
```sql
SELECT "ice_cream_icecream"."id",
       "ice_cream_icecream"."is_published",
       "ice_cream_icecream"."is_on_main",
       "ice_cream_icecream"."title",
       "ice_cream_icecream"."description",
       "ice_cream_icecream"."wrapper_id",
       "ice_cream_icecream"."category_id",
       "ice_cream_category"."id",
       "ice_cream_category"."is_published",
       "ice_cream_category"."title",
       "ice_cream_category"."slug",
       "ice_cream_category"."output_position"
FROM "ice_cream_icecream"
INNER JOIN "ice_cream_category"
    ON ("ice_cream_icecream"."category_id" = "ice_cream_category"."id") 
```

В отличие от `.values()`, метод `.select_related()` возвращает QuerySet со **списком объектов**, в которых содержатся **все поля** связанных моделей.

В шаблоне можно получить доступ к полям связанного объекта через точечную нотацию:
```django
{% for ice_cream in ice_cream_list %}
  <!-- Выводим id и title объекта IceCream -->
  <h3>{{ ice_cream.title }} ID: {{ ice_cream.id }}</h3> 
  ...
  <!-- Выводим поля связанного объекта Category -->
  <p>Категория: {{ ice_cream.category.title }}</p>
  <p>Слаг категории: {{ ice_cream.category.slug }}</p>
  <p>Порядок отображения: {{ ice_cream.category.output_order }}</p>
{% endfor %}  
```

## Фильтры в связанных моделях

Итоговую выборку, получившуюся при запросе к связанным моделям, можно фильтровать по полям связанной модели.

Например, если в проекте «Анфиса для друзей» какая-то **категория** снята с публикации (`is_published=False`) — должны быть скрыты и все сорта мороженого, связанные с этой категорией.

Выборка фильтруется через метод `.filter()` точно так же, как и при запросах к отдельной модели. Единственная разница состоит в том, что название поля связанной модели указывается через двойное подчёркивание после названия поля FK основной модели (в нашем случае Foreign Key хранится в поле `category`).

Фильтрация при работе с методом `.values()`:
```python
ice_cream_list = IceCream.objects.values(
    'id', 'title', 'category__title'
).filter(
    # Вернуть только те объекты IceCream, у которых
    # в связаном объекте Category в поле is_published хранится значение True:
    category__is_published=True
) 
```

Фильтрация при работе с методом `.select_related()`:
```python
ice_cream_list = IceCream.objects.select_related(
    'category'
).filter(
    # В точности то же самое:
    category__is_published=True
) 
```

Оба этих варианта добавят в запрос условие `WHERE`:
```sql
...
WHERE ("ice_cream_category"."is_published") 
```

Для моделей, связанных «один к одному», методы `.values()` и `.select_related()` работают так же, как и для «многие к одному».


---

### Задания

#### Задание 1/1
##### Описание задания
На главную страницу проекта выводятся описания сортов мороженого.

Дополните view-функцию `index()` в файле _homepage/views.py_: для каждого сорта мороженого выведите название связанной с ним обёртки (объекта `Wrapper`). Во view-функции `index()` получите нужную информацию из БД, передайте её в шаблон и выведите в строке, отмеченной комментарием.

Не удаляйте фильтры `is_on_main=True, is_published=True` и сортировку для модели `IceCream`.

Решить задачу можно двумя способами.

##### Подсказка
Если в решении применён метод `.values()` — обратиться к значению поля из шаблона нужно так: `{{ ice_cream.wrapper__title }}`

Если в решении применён метод `.select_related()` — обратиться к значению поля из шаблона нужно так: `{{ ice_cream.wrapper.title }}`

##### Решение задания
```python
# homepage/views.py

from django.shortcuts import render

from ice_cream.models import IceCream


def index(request):
    template = 'homepage/index.html'
    # Доработайте запрос.
    ice_cream_list = (
        IceCream.objects
        .filter(is_on_main=True, is_published=True).select_related('wrapper')
        .order_by('title')
    )
    context = {
        'ice_cream_list': ice_cream_list,
    }
    return render(request, template, context)
```

```django
<!-- templates/homepage/index.html -->
{% extends "base.html" %}
{% block title %}
  Анфиса для друзей. Главная
{% endblock %}
{% block content %}
  <h1 class="pb-2 mb-0">Главная страница</h1>
  {% for ice_cream in ice_cream_list %}
    <h3>{{ ice_cream.title }}</h3>
    <p>ID: {{ ice_cream.id }}</p>
    <p>{{ ice_cream.description }}</p>
    {% comment %} Выведите название обёртки внутри тега <p></p> {% endcomment %}
    <p>{{ ice_cream.wrapper.title }}</p>
    {% comment %} если решили через select_related: 
    {{ ice_cream.wrapper.title }}
    {% endcomment %}
  {% endfor %}
{% endblock %}
```

Много запросов — плохо, мало запросов — хорошо. Получилось хорошо!