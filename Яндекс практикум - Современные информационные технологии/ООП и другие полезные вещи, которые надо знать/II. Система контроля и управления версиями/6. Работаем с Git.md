# Работаем с Git

На примере склонированного репозитория смоделируем работу разработчика — будем менять код и фиксировать изменения в репозитории.

Откройте проект _backend_test_homework_ в редакторе кода и перейдите в терминал. На данный момент вы создали репозиторий, но не вносили изменений в файлы. Узнаем, что об этом думает Git.

Команда, которая показывает текущее состояние репозитория, — `git status`. Введите её в терминале и нажмите **Enter**:

```bash
# Ввели команду для отображения состояния репозитория...
git status

# ...и вот что Git сообщает в ответ.
On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean 
```

Git сообщит о том, что ему нечего фиксировать, а значит, изменений не было.

Теперь добавьте новый файл в директорию проекта, например _test.txt,_ и повторите команду.

```bash
On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        test.txt

nothing added to commit but untracked files present (use "git add" to track) 
```

Git ответил, что в директории появился новый файл, и сообщил нам, что этот файл не отслеживается.

Теперь откройте файл _program.py_, исправьте в нём ошибку (добавьте недостающую скобку) и сохраните файл. Посмотрите, как на эти изменения отреагировал Git.

Снова введите в терминал команду `git status`.

```bash
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   program.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        test.txt 
```

Git заметил изменения в отслеживаемом файле — _program.py_. Как и неотслеживаемые файлы, файлы в статусе **modified** он выделяет красным:

![](https://pictures.s3.yandex.net/resources/image_1702056298.png)

В скобках замечание — командой `git add` можно добавить <файл> в индекс, чтобы в дальнейшем включить изменения в коммит:

```bash
(use "git add <file>..." to include in what will be committed) 
```

## Добавление изменений в индекс

Изменения в локальном репозитории могут быть зафиксированы (закоммичены) только после того, как вы добавите их в индекс.

В индекс можно добавить изменения во всех файлах сразу, для этого есть опция `--all` (англ. _all_, «все»):

```bash
git add --all 
```

Опцию `--all` можно заменить точкой:

```bash
git add . 
```

При выполнении этих команд изменения файлов из вложенных каталогов также добавятся в индекс. Выполните команду, чтобы указать Git, какие изменения нужно будет зафиксировать.

```bash
git add program.py 
```

Теперь посмотрим, как изменились статусы файлов в репозитории:

![](https://pictures.s3.yandex.net/resources/image_1702056309.png)

Изменения в файле _program.py_ добавлены в индекс и готовы к коммиту.

Соотнесите команды и действия, которые они выполняют.

1. git commit
    
2. git add .
    
3. git clone ссылка_с_GitHub
    
4. git status
    

1. Фиксирует изменения в файле.
    
2. Добавляет все файлы в индекс.
    
3. Отображает состояние репозитория.
    
4. Клонирует удалённый репозиторий на локальный компьютер.
    

## Выполнение коммита

Каждый коммит сохраняет актуальное состояние файлов, и вы можете сравнивать разные состояния от коммита к коммиту. Пока что коммиты будут сохранены локально, на вашем компьютере, и доступны только вам.

Создадим коммит и сопроводим его комментарием. Для этого есть команда `git commit`. Ключ `-m` (от англ. _message_, «послание») даёт возможность добавить к коммиту комментарий, который пишется в кавычках после ключа:

```bash
git commit -m "Add first commit"
# Сделали первый коммит.
# Текст комментария: Add first commit. 
```

В комментариях описывайте, какие изменения были сделаны в коммите, иначе через неделю вы уже не вспомните, что и зачем было написано. Git понимает кириллицу, но комментировать по-английски — хорошая практика.

❗ Мы подготовили для вас [краткое руководство по написанию коммитов](https://code.s3.yandex.net/backend-developer/learning-materials/%D0%A8%D0%BF%D0%B0%D1%80%D0%B3%D0%B0%D0%BB%D0%BA%D0%B0%20%D0%BF%D0%BE%20%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%B0%D0%BC.pdf). Сохраните его и пользуйтесь на здоровье.

Как только вы нажмёте кнопку **Enter**, коммит сохранится, и в терминале появится отчёт:

```bash
[master 79deb7a] Add first commit
 1 file changed, 1 insertion(+), 1 deletion(-) 
```

В первой строке вы видите свой комментарий _(Add first commit)_, а перед ним, в квадратных скобках, информацию о коммите:

- **main (master)** — название ветки, в которой сделан коммит.
- **контрольная сумма, или «хеш»,** — уникальный идентификатор, присвоенный коммиту. Для удобства коммиты идентифицируются по первым семи символам контрольной суммы. В нашем примере это `79deb7a`.

Второй строкой идёт информация о файлах коммита:

- изменён один файл _(1 file changed)_;
- в изменённых файлах добавлена одна строка и одна удалена _(1 insertions(+), 1 deletions(-) )_.

Ветки, или, как их ещё называют, «бранчи», — один из инструментов Git. Ветки можно представить как разные копии одного и того же проекта. Если сравнивать с чем-то из обыденной жизни, представьте, что у вас есть чертёж дома — это ваш проект. Вы решили внести изменения, но не хотите испортить оригинальный чертёж. Поэтому вы берёте копию чертежа и вносите изменения в эту копию. В мире Git это и есть создание новой ветки. Но пока у вас никаких копий проекта нет, и вы работаете в одной-единственной ветке **main (master)**.

## Изменение сделанного коммита

Если вдруг вы забыли добавить новый файл в репозиторий и сделали это уже после коммита, необязательно делать новый коммит. Достаточно добавить изменения к последнему коммиту. Для этого есть ключ `--amend` (англ. _amend_, «исправить»):

```bash
git commit --amend -m "Текст вашего комментария" 
```

Эта команда добавит изменённые файлы в последний сделанный коммит, а с дополнительным флагом `-m` ещё и обновит комментарий:

```bash
# Делаем первый коммит, в кавычках пишем комментарий.
git commit -m "Сhange program.py"

# Добавили файлы в индекс Git.
git add .

# Добавили эти файлы к предыдущему коммиту.
git commit --amend -m "Add new files" 
```

## Отправка коммита на GitHub

Все сделанные коммиты (фактически — вся информация о внесённых изменениях) сохранены локально, на вашем компьютере — никто, кроме вас, не видит эти изменения. Чтобы ваша работа стала доступна коллегам (а в Практикуме — код-ревьюерам и наставникам), нужно отправить изменения в ваш GitHub.

Git запомнил, откуда вы клонировали репозиторий, поэтому не нужно указывать, куда именно отправлять изменения. На сленге эту операцию называют «запушить» (от англ. _push_, «протолкнуть»).

Для отправки локальных изменений на сервер GitHub выполните команду из любой директории проекта:

```bash
git push 
```

Готово! Теперь «незапушенные» коммиты отправятся на GitHub, и ваши изменения смогут увидеть все, у кого есть доступ к репозиторию.

## Что делать, если в удалённый репозиторий попали лишние файлы или папки

В процессе работы в удалённый репозиторий могут попасть файлы, которым там не место. Например, это могут быть случайные или временные файлы, или файлы, которые содержат чувствительную информацию, например пароли. Избавиться от лишнего поможет команда `git rm`.

Создайте в директории _backend_test_homework/_ файл _new.py_ и отправьте его в удалённый репозиторий:



```bash
# ...backend_test_homework/

# Добавить новые и изменённые файлы в индекс.
git add . 
# Зафиксировать изменения.
git commit -m "Add new file"
# Отправить изменения в удалённый репозиторий.
git push  
```

Зайдите в удалённый репозиторий.

Файл на месте?

Правильный ответ

Да, капитан!

Отлично, так и должно быть 😉


_new.py_ — лишний файл в удалённом репозитории. Чтобы не отслеживать его, выполните команды:



```bash
# Удаляем файл из отслеживания, но не удаляем из папки на компьютере.
git rm --cached new.py
# Фиксируем изменения в локальном репозитории.
git commit -m "Delete new file"
# Отправляем изменения в удалённый репозиторий.
git push 
```

Команда `git rm` используется для удаления файлов из индекса и рабочего каталога.

Опция `--cached` изменяет поведение `git rm` так, чтобы файл был удален только из индекса.

Теперь файл удалён из репозитория на GitHub (можете это проверить!), и локально изменения в нём больше не отслеживаются.

## Игнорирование файлов

Некоторых файлов и директорий не должно быть даже в списке неотслеживаемых, например файлов с вашими паролями или настройками конкретного компьютера. Если репозиторий публичный, то злоумышленники могут воспользоваться вашими секретными данными и взломать ваши личные аккаунты или рабочие проекты. Чтобы эти файлы не попали в удалённый репозиторий, используйте текстовый файл **._gitignore_**.

Достаточно указать в файле _.gitignore_ название директории или имя файла, и Git перестанет их «видеть». Если игнорируемый файл находится не в корне проекта, нужно указать путь до него.

В файле _.gitignore_ можно оставлять комментарии; строка комментария начинается с символа решётки `#`:

Скопировать код

```
# Игнорировать файл README.md.
README.md

# Игнорировать файл side.txt в директории build.
build/side.txt

# Игнорировать все файлы с расширением .doc
*.doc 
```

В директории проекта _backend_test_homework/_ создайте файл _text.doc_ и текстовый файл _.gitignore._ В файл _.gitignore_ добавьте строчку с текстом *_.doc_.

А теперь зайдите в Bash, перейдите в директорию _backend_test_homework/_ и выполните два действия_:_

- добавьте изменения в индекс (в каталоге появилось два новых файла) — `git add .`;
- сделайте коммит с комментарием _Add new files_.

Соотнесите команды и действия, которые они выполняют.

git commit -m "Message"
Коммитит изменения с комментарием (от англ. «послание»).

git commit --amend -m "Message"
Добавляет изменения к последнему сделанному коммиту (от англ. «исправить»).

git push
Отправляет изменения в удалённый репозиторий (от англ. «протолкнуть»).

git rm --cached имя_файла
Удаляет файл из репозитория и отслеживания.

Вы поработали с основными командами Git, изменили файлы внутри репозитория, а также структуру самого репозитория (добавили в него новые файлы). Информация об этих изменениях не пропадает бесследно, и к ней всегда можно обратиться, а как это сделать — вы узнаете уже в следующем уроке.