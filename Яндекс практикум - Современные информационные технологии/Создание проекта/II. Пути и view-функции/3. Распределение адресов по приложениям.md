# Распределение адресов по приложениям

Обычно Django-проект состоит из нескольких приложений, и каждое приложение обрабатывает свою часть запросов.

Например, в интернет-магазине ACME могут быть разные приложения:

- приложение **homepage** управляет главной страницей,
- приложение **catalog** отображает товары в каталоге.

> Приложение **catalog** у вас уже есть; создайте и зарегистрируйте новое приложение **homepage**.

Обычно адреса проектируют так, чтобы они соответствовали названиям приложений, в которых эти адреса обрабатываются. При возможности лучше соблюдать это правило, хотя оно необязательное и следовать ему на практике не всегда удаётся.

- адрес главной страницы будет обрабатываться в приложении **homepage**;
- адреса _catalog/..._ будут обрабатываться в приложении **catalog**.

Хранить адреса всех приложений в одном файле будет неудобно: в какой-то момент список разрастётся и станет нечитаемым.

Django даёт возможность разделить список `urlpatterns` на части в соответствии с приложениями и хранить эти части в директориях приложений.

В каждом приложении можно создать собственный файл _urls.py_ и в нём перечислить адреса, обрабатываемые именно этим приложением, а в корневом _urls.py_ нужно лишь указать ссылки на эти файлы.

```
acme_project/       <-- Рабочая папка Django-проекта
 ├── acme_project/   <-- Папка с настройками проекта  
 |   ├── ...
 |   ├── urls.py     <-- Корневой файл urls.py, к нему подключаются urls приложений  
 |   └── ...
 ├── catalog/        <-- Папка приложения catalog
 |   ├── ...
 |   ├── urls.py     < -- Файл urls.py с адресами приложения catalog
 |   └── ...
 ├── homepage/       <-- Папка приложения homepage
 |   ├── ...
 |   ├── urls.py     < -- Файл urls.py с адресами приложения homepage
 |   └── ...
 ... 
```

![](https://pictures.s3.yandex.net/resources/2_1685546060.png)

Чтобы сослаться из корневого _urls.py_ на файлы _urls.py_ приложений, применяют функцию `include()` (англ. «включить», «встроить»); её указывают вторым аргументом в `path()`, вместо имени view-функции:

Скопировать кодPYTHON

```
# Корневой файл urls.py 

# Импортируем встроенные функции include() и path().
from django.urls import include, path

urlpatterns = [    
    # Если на сервер пришёл запрос к главной странице,
    # Django проверит на совпадение с запрошенным URL 
    # все path() в файле urls.py приложения homepage.
    path('', include('homepage.urls')),

    # Если в приложении homepage не найдётся совпадений,
    # Django продолжит искать совпадения здесь, в корневом файле urls.py.

    # Если запрос начинается с catalog/, 
    # Django будет искать совпадения в файле urls.py
    # приложения catalog.
    path('catalog/', include('catalog.urls')),
] 
```

Приложение **homepage** создано для одной-единственной задачи: обрабатывать запросы только к главной странице — и ни к каким другим. Поэтому файл _urls.py_ этого приложения будет работать только с одним адресом:

Скопировать кодPYTHON

```
# homepage/urls.py

# Импортируем функцию path() 
# и файл homepage/views.py, в котором объявлена view-функция index().
from django.urls import path

from . import views

urlpatterns = [
    # Если вызван URL без относительного адреса (шаблон — пустые кавычки),
    # то вызывается view-функция index() из файла views.py
    path('', views.index),
] 
```

Файл _urls.py_ приложения **catalog**:

Скопировать кодPYTHON

```
# catalog/urls.py
from django.urls import path

from . import views

urlpatterns = [
    # Если пришёл запрос к относительному URL catalog/,
    # то запрос из корневого urls.py перенаправляется сюда, 
    # в файл catalog/urls.py;
    # и если в запросе после 'catalog/' ничего нет (пустая строка),
    # будет вызвана view-функция product_list() из файла catalog/views.py
    path('', views.product_list),

    # Если в запросе после 'catalog/' стоит '1/' или '2/',
    # будет вызвана view-функция product_detail() из файла catalog/views.py
    path('1/', views.product_detail),
    path('2/', views.product_detail),
] 
```

В результате проект _acme_ с маршрутизатором, описанным в трёх файлах _urls.py_, будет обрабатывать такие адреса:

![](https://pictures.s3.yandex.net/resources/3_1685546071.png)

При `include` URL будто режется на две части: часть адреса указывается в корневом _urls.py_, а оставшаяся часть — в том _urls.py_, на который ссылается `path()` из корневого файла.

Например, при запросе к URL _catalog/1/_ в корневом файле _urls.py_ сработает путь

`path('catalog/', include('catalog.urls'))`,

а в файле _catalog/urls.py_ Django будет искать шаблон, который соответствует адресу _1/_, то есть такой:

`path('1/', views.product_detail)`, без строки `catalog/`.

В начале маршрутов не нужно добавлять слеш (символ `/`): он есть в корневом _urls._ Кстати, не забывай импортировать в код функцию `path()`, view-функции и функцию `include()` в корневой _urls.py_. Без импорта ничего не заработает.

Отдельное приложение для главной страницы — **homepage** — создавать не обязательно. Запросы к главной странице можно обрабатывать в приложении **catalog**.

Но проект может вырасти: на главную страницу добавятся новости, отзывы — и без приложения homepage будет непонятно, куда разместить файлы, отвечающие за работу главной страницы. Чтобы избежать путаницы в файловой структуре, лучше заранее создать отдельное приложение для управления этой страницей. Если не пригодится — ничего страшного, а если потребуется — вот оно, готово.

Шпаргалка

Список адресов, которые обрабатывает определённое приложение, принято хранить в отдельном _urls.py_ в директории этого приложения.

Файлы _urls.py_ из приложений подключаются к корневому файлу _urls.py_ с помощью функции `include()`.

Скопировать кодPYTHON

```
# название_проекта/urls.py (корневой urls.py проекта)

from django.urls import include, path 

urlpatterns = [
    path('catalog/', include('catalog.urls')),
] 
```